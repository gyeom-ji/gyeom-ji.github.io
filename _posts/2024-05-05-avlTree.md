---
title: "AVL Tree"
author: gyeomji
date: 2024-05-05 10:00:00 +0900
categories: [Data Structure]
tags: [Data Structure, AVL Tree]
pin: false
math: true
mermaid: true
---

<br/> 
íŠ¸ë¦¬ê°€ í•œìª½ìœ¼ë¡œ ì¹˜ìš°ì³ ìë¼ë‚˜ëŠ” í˜„ìƒì„ ë°©ì§€í•˜ì—¬ <span style="color:#9fb584">**íŠ¸ë¦¬ ë†’ì´ì˜ ê· í˜•(Balance)ì„ ìœ ì§€í•˜ëŠ” ì´ì§„íƒìƒ‰íŠ¸ë¦¬**</span>ì´ë‹¤. ê· í˜• ì´ì§„íŠ¸ë¦¬ë¥¼ ë§Œë“¤ë©´ nê°œì˜ ë…¸ë“œë¥¼ ê°€ì§„ íŠ¸ë¦¬ì˜ ë†’ì´ê°€ O(logn)ì´ ë˜ì–´ <span style="color:#9fb584">**íƒìƒ‰, ì‚½ì…, ì‚­ì œ ì—°ì‚°ì— O(logn)**</span>ì˜ ìˆ˜í–‰ì‹œê°„ì„ ë³´ì¥í•œë‹¤. ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ì—ì„œ íƒìƒ‰, ì‚½ì…, ì‚­ì œ ì—°ì‚°ë“¤ì˜ ìˆ˜í–‰ì‹œê°„ì€ ê°ê° íŠ¸ë¦¬ì˜ ë†’ì´(h)ì— ë¹„ë¡€í•˜ì—¬ O(h) ì´ë‹¤. ì´ìƒì ì¸ ìƒí™©ì—ì„œëŠ” O(logn)ì˜ ìˆ˜í–‰ì‹œê°„ì„ ê°€ì§€ì§€ë§Œ, í•œìª½ìœ¼ë¡œ ì¹˜ìš°ì¹œ í¸í–¥ ì´ì§„íŠ¸ë¦¬ê°€ ë˜ë©´ íŠ¸ë¦¬ì˜ ë†’ì´ê°€ ë†’ì•„ì§ì— ë”°ë¼ O(n)ì˜ ìˆ˜í–‰ì‹œê°„ì„ ê°€ì§€ê²Œëœë‹¤. ì´ ë‹¨ì ì„ í•´ì†Œí•˜ê¸° ìœ„í•´ ë†’ì´ ê· í˜•ì„ ìœ ì§€í•˜ì—¬ í•­ìƒ O(logn)ì˜ ìˆ˜í–‰ì‹œê°„ì„ ê°€ì§€ëŠ” AVL íŠ¸ë¦¬ë¥¼ ì‚¬ìš©í•œë‹¤.

<br/> 

>ğŸ’¡  <span style="font-size: 15px">AVLíŠ¸ë¦¬ëŠ” ì‚½ì…, ì‚­ì œë¡œ ì¸í•´ ê· í˜•ì´ ê¹¨ì§ˆ ì‹œ <span style="color:#9fb584">**íšŒì „ ì—°ì‚°**</span>ì„ í†µí•´ íŠ¸ë¦¬ì˜ ê· í˜•ì„ ìœ ì§€í•œë‹¤.</span>

<br/> 

## AVL íŠ¸ë¦¬ íŠ¹ì§•

---

1. ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ì˜ ì†ì„±ì„ ê°€ì§„ë‹¤.
2. ì„ì˜ì˜ ë…¸ë“œ xì— ëŒ€í•´ xì˜ ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬ ë†’ì´ì™€ ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬ <span style="color:#9fb584">**ë†’ì´ ì°¨ì´ê°€ ìµœëŒ€ 1**</span>ì´ë‹¤.
3. ì–´ë–¤ ì‹œì ì—ì„œ ë†’ì´ ì°¨ì´ê°€ 1ë³´ë‹¤ ì»¤ì§€ë©´ íšŒì „ ì—°ì‚°ì„ í†µí•´ ê· í˜•ì„ ì¡ì•„ ë†’ì´ ì°¨ì´ë¥¼ ì¤„ì¸ë‹¤.
4. ë†’ì´ë¥¼ logNìœ¼ë¡œ ìœ ì§€í•˜ê¸° ë•Œë¬¸ì— íƒìƒ‰, ì‚½ì…, ì‚­ì œ ì—°ì‚°ì˜ ì‹œê°„ ë³µì¡ë„ëŠ” O(logN)ì´ë‹¤.

<br/>

## Balance Factor (BF)

---

: ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬ ë†’ì´ - ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬ ë†’ì´<br/>
<center>
<span style="font-size: 20px">
<span style='background-color:#c8d8b4'>Balance Factor (k) = height (left(k)) - height(right(k))</span></span></center>
<br/>

- BF = 1ì´ë©´ ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬ê°€ ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬ë³´ë‹¤ ë†’ì´ê°€ í•œë‹¨ê³„ ë†’ë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•œë‹¤.
- BF = 0ì´ë©´ ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬ì™€ ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬ì˜ ë†’ì´ê°€ ê°™ë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•œë‹¤.
- BF = -1ì´ë©´ ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬ê°€ ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬ë³´ë‹¤ ë†’ì´ê°€ í•œë‹¨ê³„ ë‚®ë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•œë‹¤.

<br/>

![balanceFactor](/assets/img/balanceFactor.png)

<br/>

## AVL íŠ¸ë¦¬ íšŒì „ ì—°ì‚°

---
  
- ì‚½ì…, ì‚­ì œ ì—°ì‚° ìˆ˜í–‰ ì‹œ íŠ¸ë¦¬ ê· í˜•ì„ ìœ ì§€í•˜ê¸° ìœ„í•´ `LL-íšŒì „`, `RR-íšŒì „`, `LR-íšŒì „`, `RL-íšŒì „` ì—°ì‚°ì„ ì‚¬ìš©í•œë‹¤.
- ê° íšŒì „ ì—°ì‚°ì˜ ìˆ˜í–‰ ì‹œê°„ì€ O(1)ì´ë‹¤.
  - ë³€ê²½ëœ ë…¸ë“œ ë ˆí¼ëŸ°ìŠ¤ ìˆ˜ê°€ O(1)ê°œì´ê¸° ë•Œë¬¸ì´ë‹¤.
- íšŒì „ ì—°ì‚°ì€ 2ê°œì˜ ê¸°ë³¸ì ì¸ ì—°ì‚°ìœ¼ë¡œ êµ¬í˜„í•œë‹¤.
  - rotateRight()
  - rotateLeft()

### LL-íšŒì „

 yëŠ” zì˜ <span style="color:#9fb584">**ì™¼ìª½**</span> ìì‹ ë…¸ë“œì´ê³ , xëŠ” yì˜ <span style="color:#9fb584">**ì™¼ìª½**</span> ìì‹ ë…¸ë“œì¸ ê²½ìš° rotateRight() ìˆ˜í–‰

#### rotateRight()

 <span style="color:#9fb584">**ì™¼ìª½ ë°©í–¥ì˜ ì„œë¸ŒíŠ¸ë¦¬ê°€ ë†’ì•„ì„œ ë¶ˆê· í˜•ì´ ë°œìƒí•  ë•Œ ì„œë¸Œ íŠ¸ë¦¬ë¥¼ ì˜¤ë¥¸ìª½ ë°©í–¥ìœ¼ë¡œ íšŒì „**</span>í•œë‹¤.

1. ë…¸ë“œ zì˜ ì™¼ìª½ ìì‹ì„ ë…¸ë“œ yì˜ ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬(T3)ë¡œ ë³€ê²½í•œë‹¤.
2. ë…¸ë“œ yì˜ ì˜¤ë¥¸ìª½ ìì‹ì„ ë…¸ë“œ zë¡œ ë³€ê²½í•œë‹¤.

>ğŸ’¡  <span style="font-size: 15px">ì„œë¸Œ íŠ¸ë¦¬ë“¤ì˜ ìœ„ì¹˜ê°€ ì¢Œì—ì„œ ìš°ë¡œ ë´¤ì„ ë•Œ, í•­ìƒ T1, T2, T3, T4 ìˆœìœ¼ë¡œ ìœ ì§€ë˜ì–´ì•¼ í•œë‹¤.</span>

<br/>

![rotateRight](/assets/img/rotateRight.png)

<br/>

``` swift
private mutating func rotateRight(_ node: Node<T>) -> Node<T>? {
    guard var x = node.left else { return nil }
    node.left = x.right
    x.right = node
        
    // ë†’ì´ ê°±ì‹ 
    node.height = max(getHeight(node.left), getHeight(node.right)) + 1
    x.height = max(getHeight(x.left), getHeight(x.right)) + 1
        
    return x // íšŒì „ í›„ xê°€ node ìë¦¬ë¡œ ì´ë™ë¨
}

```
<br/>

### RR-íšŒì „

 yëŠ” zì˜ <span style="color:#9fb584">**ì˜¤ë¥¸ìª½**</span> ìì‹ ë…¸ë“œì´ê³ , xëŠ” yì˜ <span style="color:#9fb584">**ì˜¤ë¥¸ìª½**</span> ìì‹ ë…¸ë“œì¸ ê²½ìš° rotateLeft() ìˆ˜í–‰

#### rotateLeft()

 <span style="color:#9fb584">**ì˜¤ë¥¸ìª½ ë°©í–¥ì˜ ì„œë¸ŒíŠ¸ë¦¬ê°€ ë†’ì•„ì„œ ë¶ˆê· í˜•ì´ ë°œìƒí•  ë•Œ ì„œë¸Œ íŠ¸ë¦¬ë¥¼ ì™¼ìª½ ë°©í–¥ìœ¼ë¡œ íšŒì „**</span>í•œë‹¤.

1. ë…¸ë“œ zì˜ ì˜¤ë¥¸ìª½ ìì‹ì„ ë…¸ë“œ yì˜ ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬(T2)ë¡œ ë³€ê²½í•œë‹¤.
2. ë…¸ë“œ yì˜ ì™¼ìª½ ìì‹ì„ ë…¸ë“œ zë¡œ ë³€ê²½í•œë‹¤.

>ğŸ’¡  <span style="font-size: 15px">ì„œë¸Œ íŠ¸ë¦¬ë“¤ì˜ ìœ„ì¹˜ê°€ ì¢Œì—ì„œ ìš°ë¡œ ë´¤ì„ ë•Œ, í•­ìƒ T1, T2, T3, T4 ìˆœìœ¼ë¡œ ìœ ì§€ë˜ì–´ì•¼ í•œë‹¤.</span>

<br/>

![rotateLeft](/assets/img/rotateLeft.png)

<br/>

``` swift
private mutating func rotateLeft(_ node: Node<T>) -> Node<T>? {
    guard var x = node.right else { return nil }
    node.right = x.left
    x.left = node
        
    // ë†’ì´ ê°±ì‹ 
    node.height = max(getHeight(node.left), getHeight(node.right)) + 1
    x.height = max(getHeight(x.left), getHeight(x.right)) + 1
        
    return x // íšŒì „ í›„ xê°€ node ìë¦¬ë¡œ ì´ë™ë¨
}

```

<br/>

### LR-íšŒì „

 yëŠ” zì˜ <span style="color:#9fb584">**ì™¼ìª½**</span> ìì‹ ë…¸ë“œì´ê³ , xëŠ” yì˜ <span style="color:#9fb584">**ì˜¤ë¥¸ìª½**</span> ìì‹ ë…¸ë“œì¸ ê²½ìš° left, right ìˆœìœ¼ë¡œ ì´ 2ë²ˆì˜ rotation ìˆ˜í–‰

![lrRotate](/assets/img/lrRotate.png)

<br/>

### RL-íšŒì „

 yëŠ” zì˜ <span style="color:#9fb584">**ì˜¤ë¥¸ìª½**</span> ìì‹ ë…¸ë“œì´ê³ , xëŠ” yì˜ <span style="color:#9fb584">**ì™¼ìª½**</span> ìì‹ ë…¸ë“œì¸ ê²½ìš° right, left ìˆœìœ¼ë¡œ ì´ 2ë²ˆì˜ rotation ìˆ˜í–‰

![rlRotate](/assets/img/rlRotate.png)

<br/>

## AVL íŠ¸ë¦¬ ì‚½ì… ì—°ì‚°

---
  
1. ì´ì§„íƒìƒ‰íŠ¸ë¦¬ì˜ ì‚½ì…ê³¼ ë™ì¼í•˜ê²Œ ìƒˆë¡œìš´ ë…¸ë“œë¥¼ ì‚½ì…í•œë‹¤.
2. ìƒˆë¡œ ì‚½ì…í•œ ë…¸ë“œë¡œë¶€í„° ë£¨íŠ¸ë¡œ ê±°ìŠ¬ëŸ¬ ì˜¬ë¼ê°€ë©° ê° ë…¸ë“œì˜ ì„œë¸Œ íŠ¸ë¦¬ ë†’ì´ ì°¨ì´ë¥¼ ê°±ì‹ í•œë‹¤.
   1. ì´ë•Œ ê°€ì¥ ë¨¼ì € ë¶ˆê· í˜•ì´ ë°œìƒí•œ ë…¸ë“œë¥¼ ë°œê²¬í•˜ë©´, ì´ ë…¸ë“œë¥¼ ê¸°ì¤€ìœ¼ë¡œ ìƒˆ ë…¸ë“œê°€ ì–´ë””ì— ì‚½ì…ë˜ì—ˆëŠ”ì§€ì— ë”°ë¼ ì ì ˆí•œ íšŒì „ ì—°ì‚°ì„ ìˆ˜í–‰í•œë‹¤.

<br/>

``` swift
mutating func append(_ data: T) {
    root = append(root, data)
}
    
private mutating func append(_ node: Node<T>?, _ data: T) -> Node<T>? {
    guard let node = node else { return Node(data, 1) }
        
    if node.data < data {
        node.right = append(node.right, data)
    } else {
        node.left = append(node.left, data)
    }
    // ê° ë…¸ë“œì˜ ì„œë¸Œ íŠ¸ë¦¬ ë†’ì´ ì°¨ì´ ê°±ì‹ 
    node.height = max(getHeight(node.left), getHeight(node.right)) + 1
    // ë…¸ë“œì˜ ê· í˜• ì ê²€ ë° ë¶ˆê· í˜•ì„ ë°”ë¡œ ì¡ìŒ
    return balance(node)
}

private func getBalanceFacter(_ node: Node<T>) -> Int {
    return getHeight(node.left) - getHeight(node.right)
}
    
private func getHeight(_ node: Node<T>?) -> Int {
    guard let node = node else { return -1 }
    return node.height
}
    
// ë¶ˆê· í˜• ë°œìƒ ì‹œ íšŒì „ ì—°ì‚°ìœ¼ë¡œ ë¶ˆê· í˜• í•´ì†Œ
private mutating func balance(_ node: Node<T>) -> Node<T>? {
        
    let bf = getBalanceFacter(node)
        
    // nodeì˜ ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬ê°€ ë†’ì•„ì„œ ë¶ˆê· í˜• ë°œìƒ
    if bf > 1 {
        // nodeì˜ ì™¼ìª½ ìì‹ë…¸ë“œì˜ ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬ê°€ ë†’ì€ ê²½ìš°
        // LR-íšŒì „
        if let leftChild = node.left, getBalanceFacter(leftChild) < 0 {
            node.left = rotateLeft(node.left!)
        }
        // LL-íšŒì „
        return rotateRight(node)
    }
        
    // nodeì˜ ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬ê°€ ë†’ì•„ì„œ ë¶ˆê· í˜• ë°œìƒ
    else if bf < -1 {
        // nodeì˜ ì˜¤ë¥¸ìª½ ìì‹ë…¸ë“œì˜ ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬ê°€ ë†’ì€ ê²½ìš°
        // RL-íšŒì „
        if let rightChild = node.right, getBalanceFacter(rightChild) > 0 {
            node.right = rotateRight(node.right!)
        }
        // RR-íšŒì „
        return rotateLeft(node)
    }
        
    // nodeê°€ ê· í˜•ë˜ì–´ ìˆëŠ” ê²½ìš°
    return node
}

```

<br/>

## AVL íŠ¸ë¦¬ ì‚­ì œ ì—°ì‚°

---
  
1. ì´ì§„íƒìƒ‰íŠ¸ë¦¬ì™€ ë™ì¼í•˜ê²Œ ì‚­ì œ ì—°ì‚°ì„ ìˆ˜í–‰í•œë‹¤.
2. ì‚­ì œëœ ë…¸ë“œë¡œë¶€í„° ë£¨íŠ¸ë¡œ ê±°ìŠ¬ëŸ¬ ì˜¬ë¼ê°€ë©° ë¶ˆê· í˜•ì´ ë°œìƒí•œ ê²½ìš° ì ì ˆí•œ íšŒì „ ì—°ì‚°ì„ ìˆ˜í–‰í•œë‹¤.
   1. íšŒì „ ì—°ì‚° ìˆ˜í–‰ í›„ ë¶€ëª¨ë…¸ë“œì—ì„œ ë¶ˆê· í˜•ì´ ë°œìƒí•  ìˆ˜ ìˆê³ , ì´ëŸ° ì¼ì´ ë°˜ë³µë˜ì–´ ë£¨íŠ¸ë…¸ë“œì—ì„œ íšŒì „ ì—°ì‚°ì„ ìˆ˜í–‰í•´ì•¼ í•˜ëŠ” ê²½ìš°ë„ ë°œìƒí•œë‹¤.

<br/>

``` swift
func min() -> T? {
    guard let root = root else { return nil }
    return min(root).data
}
    
private func min(_ node: Node<T>) -> Node<T> {
    guard let left = node.left else {return node}
        
    return min(left)
}
    
mutating func removeMin() {
    root = removeMin(root)
}
    
private mutating func removeMin(_ node: Node<T>?) -> Node<T>? {
    guard let node = node else { return nil }
        
    if node.left == nil { // ì™¼ìª½ ìì‹ì´ nilì´ë©´ ì˜¤ë¥¸ìª½ ìì‹ ë¦¬í„´
        return node.right
    }
    node.left = removeMin(node.left) // ì‚­ì œë  nodeì˜ ìì‹ê³¼ ë¶€ëª¨ë¥¼ ì—°ê²°ì‹œì¼œ ìµœì†Ÿê°’ ì‚­ì œ
    return node
}
    
mutating func remove(_ data: T) {
    root = remove(root, data)
}
    
private mutating func remove(_ node: Node<T>?, _ data: T) -> Node<T>? {
    guard var node = node else {return nil}
        
    if data < node.data {
        node.left = remove(node.left, data)
    } else if data > node.data {
        node.right = remove(node.right, data)
    } else {
        if node.right == nil { return node.left } // case 1 (ì˜¤ë¥¸ìª½, ì™¼ìª½ ëª¨ë‘ nil), 2 (ë‘˜ ì¤‘ í•˜ë‚˜ nil)
        if node.left == nil { return node.right } // case 2 (ë‘˜ ì¤‘ í•˜ë‚˜ nil)
            
        var target = node  // case 3
        node = min(target.right!) // ì‚­ì œë  ë…¸ë“œë¥¼ ëŒ€ì²´í•  ë…¸ë“œ(ì˜¤ë¥¸ìª½ ìì‹ ë…¸ë“œ ì¤‘ ê°€ì¥ ì‘ì€ ë…¸ë“œ)ë¥¼ ì°¾ì•„ nodeê°€ ê°€ë¦¬í‚¤ê²Œ í•œë‹¤.
        node.right = removeMin(target.right) // ëŒ€ì²´í•  ë…¸ë“œë¥¼ íŠ¸ë¦¬ì—ì„œ ë¶„ë¦¬ì‹œí‚¤ê³  ìµœì¢…ì ìœ¼ë¡œ ì‚­ì œë˜ëŠ” ë…¸ë“œ(target)ì˜ ì˜¤ë¥¸ìª½ ìì‹ë…¸ë“œì˜ ë ˆí¼ëŸ°ìŠ¤ë¥¼ ë¦¬í„´ -> nodeì˜ ì˜¤ë¥¸ìª½ ìì‹ìœ¼ë¡œ ë§Œë“ ë‹¤.
        node.left = target.left // targetë…¸ë“œì˜ ì™¼ìª½ ìì‹ì„ nodeì˜ ì™¼ìª½ ìì‹ìœ¼ë¡œ ë§Œë“ ë‹¤.
    }
        
    // ê° ë…¸ë“œì˜ ì„œë¸Œ íŠ¸ë¦¬ ë†’ì´ ì°¨ì´ ê°±ì‹ 
    node.height = max(getHeight(node.left), getHeight(node.right)) + 1
    // ë…¸ë“œì˜ ê· í˜• ì ê²€ ë° ë¶ˆê· í˜•ì„ ë°”ë¡œ ì¡ìŒ
    return balance(node)
}

```

<br/>


## AVL íŠ¸ë¦¬ ì „ì²´ ì½”ë“œ

---

``` swift

final class Node<T: Comparable> {
    var data: T
    var height : Int
    var left: Node<T>?
    var right: Node<T>?
    
    init(_ data: T,_ height: Int, _ left: Node<T>? = nil, _ right: Node<T>? = nil){
        self.data = data
        self.height = height
        self.left = left
        self.right = right
    }
}

extension Node: CustomStringConvertible {
    
    public var description: String {
        return diagram(for: self)
    }
    
    private func diagram(for node: Node?,
                         _ top: String = "",
                         _ root: String = "",
                         _ bottom: String = "") -> String {
        guard let node = node else {
            return root + "nil\n"
        }
        if node.left == nil && node.right == nil {
            return root + "\(node.data)\n"
        }
        return diagram(for: node.right, top + " ", top + "â”Œâ”€â”€", top + "â”‚ ")
        + root + "\(node.data)\n"
        + diagram(for: node.left, bottom + "â”‚ ", bottom + "â””â”€â”€", bottom + " ")
    }
}

struct AVLTree<T: Comparable>: CustomStringConvertible {
    var root : Node<T>?
    
    public var description: String {
        guard let root = root else { return "empty tree" }
        return String(describing: root)
    }
    
    private func getBalanceFacter(_ node: Node<T>) -> Int {
        return getHeight(node.left) - getHeight(node.right)
    }
    
    private func getHeight(_ node: Node<T>?) -> Int {
        guard let node = node else { return -1 }
        return node.height
    }
    
    // ë¶ˆê· í˜• ë°œìƒ ì‹œ íšŒì „ ì—°ì‚°ìœ¼ë¡œ ë¶ˆê· í˜• í•´ì†Œ
    private mutating func balance(_ node: Node<T>) -> Node<T> {
        
        let bf = getBalanceFacter(node)
        
        // nodeì˜ ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬ê°€ ë†’ì•„ì„œ ë¶ˆê· í˜• ë°œìƒ
        if bf > 1 {
            // nodeì˜ ì™¼ìª½ ìì‹ë…¸ë“œì˜ ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬ê°€ ë†’ì€ ê²½ìš°
            // LR-íšŒì „
            if let leftChild = node.left, getBalanceFacter(leftChild) < 0 {
                node.left = rotateLeft(node.left!)
            }
            // LL-íšŒì „
            return rotateRight(node)
        }
        
        // nodeì˜ ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬ê°€ ë†’ì•„ì„œ ë¶ˆê· í˜• ë°œìƒ
        else if bf < -1 {
            // nodeì˜ ì˜¤ë¥¸ìª½ ìì‹ë…¸ë“œì˜ ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬ê°€ ë†’ì€ ê²½ìš°
            // RL-íšŒì „
            if let rightChild = node.right, getBalanceFacter(rightChild) > 0 {
                node.right = rotateRight(node.right!)
            }
            // RR-íšŒì „
            return rotateLeft(node)
        }
        
        // nodeê°€ ê· í˜•ë˜ì–´ ìˆëŠ” ê²½ìš°
        return node
    }
    
    private mutating func rotateRight(_ node: Node<T>) -> Node<T> {
        guard var x = node.left else { return node }
        node.left = x.right
        x.right = node
        
        // ë†’ì´ ê°±ì‹ 
        node.height = max(getHeight(node.left), getHeight(node.right)) + 1
        x.height = max(getHeight(x.left), getHeight(x.right)) + 1
        
        return x // íšŒì „ í›„ xê°€ nodeì˜ ì´ì „ ìë¦¬ë¡œ ì´ë™ë¨
    }
    
    private mutating func rotateLeft(_ node: Node<T>) -> Node<T> {
        guard var x = node.right else { return node }
        node.right = x.left
        x.left = node
        
        // ë†’ì´ ê°±ì‹ 
        node.height = max(getHeight(node.left), getHeight(node.right)) + 1
        x.height = max(getHeight(x.left), getHeight(x.right)) + 1
        
        return x // íšŒì „ í›„ xê°€ nodeì˜ ì´ì „ ìë¦¬ë¡œ ì´ë™ë¨
    }
    
    mutating func append(_ data: T) {
        root = append(root, data)
    }
    
    private mutating func append(_ node: Node<T>?, _ data: T) -> Node<T>? {
        guard let node = node else { return Node(data, 0) }
        
        if node.data < data {
            node.right = append(node.right, data)
        } else {
            node.left = append(node.left, data)
        }
        
        // ê° ë…¸ë“œì˜ ì„œë¸Œ íŠ¸ë¦¬ ë†’ì´ ì°¨ì´ ê°±ì‹ 
        node.height = max(getHeight(node.left), getHeight(node.right)) + 1
        // ë…¸ë“œì˜ ê· í˜• ì ê²€ ë° ë¶ˆê· í˜•ì„ ë°”ë¡œ ì¡ìŒ
        return balance(node)
    }
    
    func min() -> T? {
        guard let root = root else { return nil }
        return min(root).data
    }
    
    private func min(_ node: Node<T>) -> Node<T> {
        guard let left = node.left else {return node}
        
        return min(left)
    }
    
    mutating func removeMin() {
        root = removeMin(root)
    }
    
    private mutating func removeMin(_ node: Node<T>?) -> Node<T>? {
        guard let node = node else { return nil }
        
        if node.left == nil { // ì™¼ìª½ ìì‹ì´ nilì´ë©´ ì˜¤ë¥¸ìª½ ìì‹ ë¦¬í„´
            return node.right
        }
        node.left = removeMin(node.left) // ì‚­ì œë  nodeì˜ ìì‹ê³¼ ë¶€ëª¨ë¥¼ ì—°ê²°ì‹œì¼œ ìµœì†Ÿê°’ ì‚­ì œ
        return node
    }
    
    mutating func remove(_ data: T) {
        root = remove(root, data)
    }
    
    private mutating func remove(_ node: Node<T>?, _ data: T) -> Node<T>? {
        guard var node = node else {return nil}
        
        if data < node.data {
            node.left = remove(node.left, data)
        } else if data > node.data {
            node.right = remove(node.right, data)
        } else {
            if node.right == nil { return node.left } // case 1 (ì˜¤ë¥¸ìª½, ì™¼ìª½ ëª¨ë‘ nil), 2 (ë‘˜ ì¤‘ í•˜ë‚˜ nil)
            if node.left == nil { return node.right } // case 2 (ë‘˜ ì¤‘ í•˜ë‚˜ nil)
            
            var target = node  // case 3
            node = min(target.right!) // ì‚­ì œë  ë…¸ë“œë¥¼ ëŒ€ì²´í•  ë…¸ë“œ(ì˜¤ë¥¸ìª½ ìì‹ ë…¸ë“œ ì¤‘ ê°€ì¥ ì‘ì€ ë…¸ë“œ)ë¥¼ ì°¾ì•„ nodeê°€ ê°€ë¦¬í‚¤ê²Œ í•œë‹¤.
            node.right = removeMin(target.right) // ëŒ€ì²´í•  ë…¸ë“œë¥¼ íŠ¸ë¦¬ì—ì„œ ë¶„ë¦¬ì‹œí‚¤ê³  ìµœì¢…ì ìœ¼ë¡œ ì‚­ì œë˜ëŠ” ë…¸ë“œ(target)ì˜ ì˜¤ë¥¸ìª½ ìì‹ë…¸ë“œì˜ ë ˆí¼ëŸ°ìŠ¤ë¥¼ ë¦¬í„´ -> nodeì˜ ì˜¤ë¥¸ìª½ ìì‹ìœ¼ë¡œ ë§Œë“ ë‹¤.
            node.left = target.left // targetë…¸ë“œì˜ ì™¼ìª½ ìì‹ì„ nodeì˜ ì™¼ìª½ ìì‹ìœ¼ë¡œ ë§Œë“ ë‹¤.
        }
        
        // ê° ë…¸ë“œì˜ ì„œë¸Œ íŠ¸ë¦¬ ë†’ì´ ì°¨ì´ ê°±ì‹ 
        node.height = max(getHeight(node.left), getHeight(node.right)) + 1
        // ë…¸ë“œì˜ ê· í˜• ì ê²€ ë° ë¶ˆê· í˜•ì„ ë°”ë¡œ ì¡ìŒ
        return balance(node)
    }
}

```

<br/>

[^footnote]: The footnote source
[^fn-nth-2]: The 2nd footnote source
