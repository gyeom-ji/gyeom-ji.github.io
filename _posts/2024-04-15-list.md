---
title: "List"
author: gyeomji
date: 2024-04-15 10:00:00 +0900
categories: [Data Structure]
tags: [Data Structure, Array, LinkedList]
pin: false
math: true
mermaid: true
---

<br/> 
ListëŠ” ì¼ë ¨ì˜ ë™ì¼í•œ íƒ€ì…ì˜ í•­ëª©ë“¤ì„ ê°€ì§€ê³  ìˆëŠ” ìë£Œêµ¬ì¡°ë¡œ,  <span style="color:#9fb584">**ë°°ì—´**</span>ê³¼  <span style="color:#9fb584">**ì—°ê²° ë¦¬ìŠ¤íŠ¸**</span>ë¡œ ë‚˜ëˆ ì§„ë‹¤.
<br/> 

## ë°°ì—´ Array

---

: ë™ì¼í•œ íƒ€ì…ì˜ ì›ì†Œë“¤ì´ <span style="color:#9fb584">**ì—°ì†ì ì¸**</span> ë©”ëª¨ë¦¬ ê³µê°„ì— í• ë‹¹ë˜ì–´ ê° í•­ëª©ì´ í•˜ë‚˜ì˜ ì›ì†Œì— ì €ì¥ë˜ëŠ” ê¸°ë³¸ì ì¸ ìë£Œêµ¬ì¡°<br />

[ ìˆ˜í–‰ ì‹œê°„ ]

- find ì—°ì‚° : O(1)
    : íŠ¹ì • ìœ„ì¹˜ ì›ì†Œ ì ‘ê·¼ ì‹œ ë°°ì—´ ì¸ë±ìŠ¤ë¥¼ ì‚¬ìš©
- **search ì—°ì‚° : O(n)**
- ì‚½ì…, ì‚­ì œ ì—°ì‚° : ìµœì•…ì˜ ê²½ìš° O(n)
    : ìƒˆ í•­ëª©ì„ ë°°ì—´ ì¤‘ê°„ì— ì‚½ì…í•˜ê±°ë‚˜, ì¤‘ê°„ í•­ëª© ì‚­ì œ ì‹œ ì• ë’¤ í•­ëª©ë“¤ì„ í•œ ì¹¸ì”© ì•ë’¤ë¡œ ì´ë™ì‹œì¼œì•¼ í•œë‹¤.

<br/>

## ë‹¨ìˆœ ì—°ê²° ë¦¬ìŠ¤íŠ¸ Singly Linked List

---

: <span style="color:#9fb584">**ë™ì  ë©”ëª¨ë¦¬ í• ë‹¹**</span>ì„ ì´ìš©í•´ ë¦¬ìŠ¤íŠ¸ë¥¼ êµ¬í˜„í•˜ëŠ” ê°€ì¥ ê°„ë‹¨í•œ í˜•íƒœì˜ ìë£Œêµ¬ì¡°<br />ë™ì  ë©”ëª¨ë¦¬ í• ë‹¹ì„ ë°›ì•„ ë…¸ë“œë¥¼ ì €ì¥í•˜ê³ , ë…¸ë“œëŠ” ë ˆí¼ëŸ°ìŠ¤ë¥¼ ì´ìš©í•´ ë‹¤ìŒ ë…¸ë“œë¥¼ ê°€ë¦¬í‚¤ë„ë¡ ë§Œë“¤ì–´ ë…¸ë“œë“¤ì„ í•œ ì¤„ë¡œ ì—°ê²°ì‹œí‚¨ë‹¤.

[ ë…¸ë“œ êµ¬ì¡° ]
1. ìì‹ ì´ ê°€ì§€ê³  ìˆëŠ” ê°’
2. ë‹¤ìŒ ë…¸ë“œë¥¼ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„°
<br />

![singlyLinkedList](/assets/img/linkedList.png){: width="400" height="300"}

<br />

[ ìˆ˜í–‰ ì‹œê°„ ]
- search, find ì—°ì‚° : O(n)
    : ë…¸ë“œë“¤ì„ head ë¶€í„° ìˆœì°¨íƒìƒ‰ í•´ì•¼í•œë‹¤.
- ì‚½ì… ì—°ì‚° : O(n)
    : ë³„ë„ì˜ ìš©ë„ë¡œ íŠ¹ì • ë…¸ë“œë¥¼ ê°€ë¦¬í‚¤ê³  ìˆëŠ” í¬ì¸í„°ê°€ ìˆì„ ì‹œ O(1) (ì œì¼ ì• ì›ì†Œ)
- ì‚­ì œ ì—°ì‚° : O(n)
    : ì´ì „ ë…¸ë“œë¥¼ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„°ê°€ ì—†ê¸° ë•Œë¬¸ì— search ì‘ì—…ì„ í•´ì•¼í•˜ë¯€ë¡œ O(n)

<br/>

## ë‹¨ìˆœ ì—°ê²° ë¦¬ìŠ¤íŠ¸ ì‚¬ìš©í•´ í•´ê²°í•œ ë¬¸ì œ

---

- í•™ë²ˆ, ì´ë¦„, ê°€ì… ë™ì•„ë¦¬ë¥¼ ì €ì¥í•˜ëŠ” ë…¸ë“œë¥¼ êµ¬ì„±í•˜ê³ , ì´ë¥¼ í•™ë²ˆ ìˆœì„œëŒ€ë¡œ ìœ ì§€í•˜ëŠ” ë‹¨ìˆœì—°ê²°ë¦¬ìŠ¤íŠ¸ë¥¼ êµ¬ì„±
- í•™ë²ˆê³¼ ì´ë¦„ì—ëŠ” ê³µë°±ì—†ê³ , ë™ì•„ë¦¬ëŠ” ì—†ì„ ìˆ˜ë„ ìˆìœ¼ë©° ì—¬ëŸ¬ ê°œë¼ë©´ â€œ/â€ë¡œ êµ¬ë¶„
    - ê°€ì… ë™ì•„ë¦¬ëŠ” ë‹¤ì‹œ ë‹¨ìˆœì—°ê²°ë¦¬ìŠ¤íŠ¸ì— í¬í•¨ëœ ë‹¨ìˆœì—°ê²°ë¦¬ìŠ¤íŠ¸ë¡œ êµ¬í˜„
- dummy head nodeì™€ tail nodeë¥¼ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” êµ¬ì¡°ë¡œ êµ¬í˜„

```swift
import Foundation

final class Node<T: Comparable> {
    var data: T
    var next: Node<T>?
    
    init(_ data: T, _ next: Node<T>? = nil) {
        self.data = data
        self.next = next
    }
    
    static func < (lhs: Node<T>, rhs: Node<T>) -> Bool {
        return lhs.data < rhs.data
    }
    
    static func == (lhs: Node<T>, rhs: Node<T>) -> Bool {
        return lhs.data == rhs.data
    }
}

final class Student: Comparable, CustomStringConvertible {
    var name: String
    var id: String
    var club: SinglyLinkedList<String>?
    
    init(name: String, id: String, club: SinglyLinkedList<String>? = nil) {
        self.name = name
        self.id = id
        self.club = club
    }
    
    static func < (lhs: Student, rhs: Student) -> Bool {
        return lhs.id < rhs.id
    }
    
    static func == (lhs: Student, rhs: Student) -> Bool {
        return lhs.id == rhs.id
    }
    
    var description: String {
        guard let club = club else {
            return "\(id) \(name)"
        }
        
        return "\(id) \(name) \(club)"
    }
}

struct SinglyLinkedList<T: Comparable>: CustomStringConvertible {
    private var head: Node<T>?
    
    mutating func insert(_ data: T) -> Bool {
        let newNode = Node(data)
        var cur = head
        var pre: Node<T>?
        
        while cur != nil && data >= cur!.data {
            if cur?.data == data {
                return false
            }
            
            pre = cur
            cur = cur?.next
        }
        newNode.next = cur
        
        if pre == nil {
            head = newNode
        } else {
            pre?.next = newNode
        }
        return true
    }
    
    mutating func remove(_ target: T) -> Bool {
        var cur = head
        var pre: Node<T>?
        var check = false
        
        while cur != nil {
            if cur?.data == target {
                check = true
                break
            }
            pre = cur
            cur = cur?.next
        }
        
        if !check {
            return false
        }
        
        if pre == nil {
            head = cur?.next
        } else {
            pre?.next = cur?.next
        }
        
        return true
    }
    
    var description: String {
        var str = ""
        var cur = head
        
        if T.self == String.self {
            while cur != nil {
                str += cur?.next != nil ? "\(cur!.data)/" : "\(cur!.data)"
                cur = cur?.next
            }
        } else {
            while cur != nil {
                str += cur?.next != nil ? "\(cur!.data)\n" : "\(cur!.data)"
                cur = cur?.next
            }
        }
        return str
    }
}

func solution() {
    var list = SinglyLinkedList<Student>()

    let fileManager: FileManager = FileManager.default
    let documentPath: URL = fileManager.urls(for: .documentDirectory, in: .userDomainMask)[0]
    let directoryPath: URL = documentPath.appendingPathComponent("ìƒˆ í´ë”")
    let textPath: URL = directoryPath.appendingPathComponent("std.txt")
    
    do {
        let dataFromPath: Data = try Data(contentsOf: textPath)
        let data: String = String(data: dataFromPath, encoding: .utf8) ?? "ë¬¸ì„œì—†ìŒ"
        var dataArr = data.components(separatedBy: "\n")
        
        for data in dataArr {
            let studentArr = data.components(separatedBy: " ")
            insertToList(studentArr)
        }
    } catch let e {
        print(e.localizedDescription)
    }
    
loop:
    while true {
        print("""
              ===============================
              (1) ìƒˆ í•™ìƒ ì…ë ¥
              (2) í•™ìƒ ì‚­ì œ
              (3) í•™ë²ˆ ìˆœìœ¼ë¡œ ì „ì²´ ì¶œë ¥
              (4) íŒŒì¼ì— ì €ì¥í•˜ê³  ì¢…ë£Œ
              =============================== 
              """)
        print("ì›í•˜ëŠ” ê¸°ëŠ¥ì„ ì„ íƒí•˜ì„¸ìš” : ", terminator: "")
        var menu = Int(readLine()!)!
        
        
        switch(menu) {
            
        case 1:// insert
            print("í•™ë²ˆê³¼ ì´ë¦„, ë™ì•„ë¦¬ë“¤ì„ ì…ë ¥í•˜ì„¸ìš” : ", terminator: "")
            let studentArr = readLine()!.components(separatedBy: " ")
            insertToList(studentArr)
            break
            
        case 2:// delete
            print("í•™ë²ˆì„ ì…ë ¥í•˜ì„¸ìš” : ", terminator: "")
            let id = readLine()!
            if !list.remove(Student(name: "", id: id)) {
                print("í•´ë‹¹ í•™ë²ˆì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")
            }
            break
            
        case 3:
            print(list)
            break
            
        case 4:
            do {
                try fileManager.createDirectory(at: directoryPath, withIntermediateDirectories: false, attributes: nil)
            } catch let e {
                print(e.localizedDescription)
            }

            if let data: Data = list.description.data(using: String.Encoding.utf8) {
                do {
                    try data.write(to: textPath)
                } catch let e {
                    print(e.localizedDescription)
                }
            }

            print("ì¢…ë£Œí•©ë‹ˆë‹¤")
            break loop
            
        default:
            break
        }
    }
    
    func insertToList(_ studentArr: [String]) {
        if studentArr.count > 2 {
            let clubArr = studentArr[2].components(separatedBy: "/")
            var clubLinkedList = SinglyLinkedList<String>()
            
            for club in clubArr {
                if !clubLinkedList.insert(String(club)) {
                    print("ë™ì¼í•œ ë™ì•„ë¦¬ê°€ ì¡´ì¬í•˜ì—¬ ì…ë ¥í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")
                }
            }
            if !list.insert(Student(name: studentArr[1], id: studentArr[0], club: clubLinkedList)) {
                print("ë™ì¼í•œ í•™ë²ˆì´ ì¡´ì¬í•˜ì—¬ ì…ë ¥í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")
            }
        } else {
            if !list.insert(Student(name: studentArr[1], id: studentArr[0])) {
                print("ë™ì¼í•œ í•™ë²ˆì´ ì¡´ì¬í•˜ì—¬ ì…ë ¥í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")
            }
        }
    }
}

solution()

```

- ë°°ìš´ì 
  : Nodeë¥¼ êµ¬ì¡°ì²´ë¡œ êµ¬í˜„í•  ê²½ìš° ê°’ ë³€ê²½(next í”„ë¡œí¼í‹° ë³€ê²½)ì— ë”°ë¼ ê°’ì´ ë³µì‚¬ë˜ì–´ ìƒˆë¡œìš´ ì¸ìŠ¤í„´ìŠ¤ê°€ ìƒì„±ëœë‹¤.(ìŠ¤íƒ ë©”ëª¨ë¦¬ ê³µê°„ ë§ì´ ì†Œìš”) ì—°ê²° ë¦¬ìŠ¤íŠ¸ëŠ” ë°ì´í„°ì˜ ìƒíƒœë¥¼ ê³„ì† ë°”ê¿” ì—…ë°ì´íŠ¸ í•´ì•¼ í•˜ê¸° ë•Œë¬¸ì— í´ë˜ìŠ¤ë¡œ êµ¬í˜„í–ˆê³ , final í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ëŸ°íƒ€ì„ ì„±ëŠ¥ì„ í–¥ìƒ ì‹œì¼°ë‹¤.

<br/>
<br/>

## ì´ì¤‘ ì—°ê²° ë¦¬ìŠ¤íŠ¸ Doubly Linked List

---

: ê° ë…¸ë“œê°€ <span style="color:#9fb584">**ë‘ ê°œì˜ ë ˆí¼ëŸ°ìŠ¤ë¡œ ê°ê° ì´ì „ ë…¸ë“œì™€ ë‹¤ìŒ ë…¸ë“œë¥¼ ê°€ë¦¬í‚¤ëŠ” ì—°ê²°ë¦¬ìŠ¤íŠ¸**</span>ì´ë‹¤. ë‹¨ìˆœì—°ê²°ë¦¬ìŠ¤íŠ¸ëŠ” ì‚½ì…, ì‚­ì œ ì‹œ ë°˜ë“œì‹œ ì´ì „ ë…¸ë“œë¥¼ ê°€ë¦¬í‚¤ëŠ” ë ˆí¼ëŸ°ìŠ¤ë¥¼ ì¶”ê°€ë¡œ ì•Œì•„ë‚´ì•¼í•˜ê³ , ì—­ë°©í–¥ìœ¼ë¡œ ë…¸ë“œ íƒìƒ‰ì´ ë¶ˆê°€í•˜ë‹¤. ì´ì¤‘ì—°ê²°ë¦¬ìŠ¤íŠ¸ëŠ” ì´ëŸ¬í•œ ë‹¨ì ì„ ë³´ì™„í•˜ì§€ë§Œ, ê° ë…¸ë“œë§ˆë‹¤ í•œ ê°œì˜ ë ˆí¼ëŸ°ìŠ¤ë¥¼ ì¶”ê°€ë¡œ ì €ì¥í•´ì•¼ í•œë‹¤ëŠ” ë‹¨ì ì´ ìˆë‹¤.

[ ë…¸ë“œ êµ¬ì¡° ]
1. ìì‹ ì´ ê°€ì§€ê³  ìˆëŠ” ê°’
2. ë‹¤ìŒ ë…¸ë“œë¥¼ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„°
3. ì´ì „ ë…¸ë“œë¥¼ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„°
<br />

![doublyLinkedList](/assets/img/doublyLinkedList.png){: width="400" height="300"}
<br />

[ ìˆ˜í–‰ ì‹œê°„ ]
- search, find ì—°ì‚° : O(n)
    : ë…¸ë“œë“¤ì„ head ë˜ëŠ” tail ë¶€í„° ìˆœì°¨íƒìƒ‰ í•´ì•¼í•œë‹¤.
- ì‚½ì…, ì‚­ì œ ì—°ì‚° : O(1)
    : ì¶”ê°€, ì‚­ì œí•˜ë ¤ëŠ” ìœ„ì¹˜ì˜ ë…¸ë“œë¥¼ ì•„ëŠ” ê²½ìš° (ì´ì „ ë…¸ë“œë¥¼ ê°€ë¥´í‚¤ëŠ” í¬ì¸í„°ê°€ ìˆê¸° ë•Œë¬¸)


<br/>

## ì´ì¤‘ ì—°ê²° ë¦¬ìŠ¤íŠ¸ ì‚¬ìš©í•´ í•´ê²°í•œ ë¬¸ì œ

---

#### Programmers - í‘œ í¸ì§‘

\- ì²˜ìŒ í‘œì—ì„œ ëª…ë ¹ì–´ë¥¼ ìˆ˜í–‰í•œ í›„ì˜ í‘œ ìƒíƒœë¥¼ ë¹„êµí•˜ì—¬ ì‚­ì œë˜ì§€ ì•Šì€ í–‰ì€ O, ì‚­ì œëœ í–‰ì€ Xë¡œ í‘œì‹œí•œ ë¬¸ìì—´ì„ êµ¬í•˜ëŠ” ë¬¸ì œ<br />
- "U X": í˜„ì¬ ì„ íƒëœ í–‰ì—ì„œ Xì¹¸ ìœ„ì— ìˆëŠ” í–‰ì„ ì„ íƒí•©ë‹ˆë‹¤.
- "D X": í˜„ì¬ ì„ íƒëœ í–‰ì—ì„œ Xì¹¸ ì•„ë˜ì— ìˆëŠ” í–‰ì„ ì„ íƒí•©ë‹ˆë‹¤.
- "C" : í˜„ì¬ ì„ íƒëœ í–‰ì„ ì‚­ì œí•œ í›„, ë°”ë¡œ ì•„ë˜ í–‰ì„ ì„ íƒí•©ë‹ˆë‹¤. ë‹¨, ì‚­ì œëœ í–‰ì´ ê°€ì¥ ë§ˆì§€ë§‰ í–‰ì¸ ê²½ìš° ë°”ë¡œ ìœ— í–‰ì„ ì„ íƒí•©ë‹ˆë‹¤.
- "Z" : ê°€ì¥ ìµœê·¼ì— ì‚­ì œëœ í–‰ì„ ì›ë˜ëŒ€ë¡œ ë³µêµ¬í•©ë‹ˆë‹¤. ë‹¨, í˜„ì¬ ì„ íƒëœ í–‰ì€ ë°”ë€Œì§€ ì•ŠìŠµë‹ˆë‹¤.

> ğŸ’¡ ì•,ë’¤ë¡œ íƒìƒ‰ì„ í•´ì•¼í•˜ê¸° ë•Œë¬¸ì— ì´ì¤‘ì—°ê²°ë¦¬ìŠ¤íŠ¸ ì‚¬ìš©

<br />

```swift
import Foundation

final class Node {
    var data: Int
    var next: Node?
    var pre: Node?

    init(_ data: Int, _ next: Node? = nil, _ pre: Node? = nil) {
        self.data = data
        self.next = next
        self.pre = pre
    }
}

struct DoublyLinkedList {
    var head: Node?
    var tail: Node?
    var cur: Node?
    var removeArr : [Bool] = []

    mutating func append(_ data: Int, _ isCurrent: Bool) {
        let node = Node(data)

        if head == nil {
            head = node
            tail = node
        } else {
            tail?.next = node
            node.pre = tail
            tail = node
        }
        if isCurrent {
            cur = node
        }
        removeArr.append(false)
    }

    mutating func remove() -> Node?{
        let removeNode = cur

        removeNode?.pre?.next = removeNode?.next
        removeNode?.next?.pre = removeNode?.pre
        
        removeArr[removeNode!.data] = true
        
        cur = removeNode?.next == nil ? removeNode?.pre : removeNode?.next

        return removeNode
    }

    mutating func restore(_ node: Node?) {
        node?.pre?.next = node
        node?.next?.pre = node
        removeArr[node!.data] = false
    }

    mutating func selectUp(_ value: Int) {
        for _ in 0..<value {
            cur = cur?.pre
        }
    }

    mutating func selectDown(_ value: Int) {
        for _ in 0..<value {
            cur = cur?.next
        }
    }
}
func solution(_ n:Int, _ k:Int, _ cmd:[String]) -> String {

    var list = DoublyLinkedList()
    var removeStack = [Node?]()

    for i in 0..<n {
        list.append(i, i == k)
    }

    for command in cmd {
        let com = command.components(separatedBy: " ")

        switch(com[0]) {
            
            case "C" : //remove
                removeStack.append(list.remove())
                break
            case "Z" : //restore
                list.restore(removeStack.removeLast())
                break
            case "U" :
                list.selectUp(Int(com[1])!)
                break
            case "D" :
                list.selectDown(Int(com[1])!)
                break
            default:
                break
        }
    }

    return list.removeArr.map {$0 ? "X" : "O"}.joined()
}

```
- ë°°ìš´ì 
  : ìœ„, ì•„ë˜ë¡œ íƒìƒ‰ì„ í•´ì•¼í•˜ê¸° ë•Œë¬¸ì— ì´ì¤‘ ì—°ê²° ë¦¬ìŠ¤íŠ¸ë¥¼ ì‚¬ìš©í–ˆê³ , ê°€ì¥ ìµœê·¼ì— ì‚­ì œëœ í–‰ì„ ë³µêµ¬í•´ì•¼í•˜ê¸° ë•Œë¬¸ì— stackì„ ì´ìš©í•´ ë¬¸ì œë¥¼ í•´ê²°í–ˆë‹¤.

<br />

## ì›í˜• ì—°ê²° ë¦¬ìŠ¤íŠ¸ Circular Linked List

---

: <span style="color:#9fb584">**ë§ˆì§€ë§‰ ë…¸ë“œê°€ ì²« ë…¸ë“œì™€ ì—°ê²°**</span>ëœ ë‹¨ìˆœì—°ê²°ë¦¬ìŠ¤íŠ¸ì´ë‹¤. ë§ˆì§€ë§‰ ë…¸ë“œì˜ ë ˆí¼ëŸ°ìŠ¤ê°€ ì €ì¥ëœ Lastê°€ ë‹¨ìˆœì—°ê²°ë¦¬ìŠ¤íŠ¸ì˜ head ê°™ì€ ì—­í• ì„ í•œë‹¤. 

- ë§ˆì§€ë§‰ ë…¸ë“œì™€ ì²« ë…¸ë“œë¥¼ O(1) ì‹œê°„ì— ë°©ë¬¸í•  ìˆ˜ ìˆë‹¤.
- ë¦¬ìŠ¤íŠ¸ê°€ emptyê°€ ì•„ë‹ˆë©´ ì–´ë–¤ ë…¸ë“œë„ null ë ˆí¼ëŸ°ìŠ¤ë¥¼ ê°€ì§€ê³  ìˆì§€ ì•Šê¸° ë•Œë¬¸ì— nullì¡°ê±´ì„ ê²€ì‚¬í•˜ì§€ ì•Šì•„ë„ ëœë‹¤ -> ì†ë„ í–¥ìƒ
- ë°˜ëŒ€ ë°©í–¥ìœ¼ë¡œ ë…¸ë“œë¥¼ ë°©ë¬¸í•˜ê¸° ì‰½ì§€ ì•Šë‹¤.
- ë¬´í•œ ë£¨í”„ê°€ ë°œìƒí•  ìˆ˜ ìˆë‹¤.
    - ì´ì¤‘ ì›í˜• ì—°ê²°ë¦¬ìŠ¤íŠ¸ë¡œ í•´ê²°
<br />

![circularLinkedList](/assets/img/circularLinkedList.png){: width="400" height="300"}
<br />
[ ìˆ˜í–‰ ì‹œê°„ ]
- search, find ì—°ì‚° : O(n)
    : ë…¸ë“œë“¤ì„ last ë¶€í„° ìˆœì°¨íƒìƒ‰ í•´ì•¼í•œë‹¤.
- **ì‚½ì… ì‚­ì œ ì—°ì‚° : O(1)**

<br/>

## ì›í˜• ì´ì¤‘ ì—°ê²° ë¦¬ìŠ¤íŠ¸ ì‚¬ìš©í•´ í•´ê²°í•œ ë¬¸ì œ

---

- í•™ë²ˆê³¼ ì´ë¦„ì„ ì €ì¥í•˜ëŠ” ë…¸ë“œë¥¼ êµ¬ì„±í•˜ê³ , ì´ë¥¼ í•™ë²ˆ ìˆœì„œëŒ€ë¡œ ìœ ì§€í•˜ëŠ” ì›í˜•ì´ì¤‘ì—°ê²°ë¦¬ìŠ¤íŠ¸ë¥¼ êµ¬ì„±
- dummy head nodeë¥¼ ì‚¬ìš©í•˜ëŠ” êµ¬ì¡°ë¡œ ëª¨ë‘ êµ¬í˜„

```swift
import Foundation

final class Node<T: Comparable> {
    var data: T
    var next: Node<T>?
    var prev: Node<T>?
    
    init(_ data: T, _ next: Node<T>? = nil, _ prev: Node<T>? = nil) {
        self.data = data
        self.next = next
        self.prev = prev
    }
    
    static func < (lhs: Node<T>, rhs: Node<T>) -> Bool {
        return lhs.data < rhs.data
    }
    
    static func == (lhs: Node<T>, rhs: Node<T>) -> Bool {
        return lhs.data == rhs.data
    }
}

final class Student: Comparable, CustomStringConvertible {
    var name: String
    var id: String
    
    init(name: String, id: String) {
        self.name = name
        self.id = id
    }
    
    static func < (lhs: Student, rhs: Student) -> Bool {
        return lhs.id < rhs.id
    }
    
    static func == (lhs: Student, rhs: Student) -> Bool {
        return lhs.id == rhs.id
    }
    
    var description: String {
        return "\(id) \(name)"
    }
}

struct CircularLinkedList<T: Comparable>: CustomStringConvertible {
    private var head: Node<T>
    private var size: Int = 0
    
    init(head: Node<T>) {
        self.head = head
        head.prev = head
        head.next = head
    }
    
    mutating func insert(_ data: T) -> Bool {
        var cur = head.next
        var pre = head
        
        if size == 0 {
            let newNode = Node(data, head, head)
            head.next = newNode
            head.prev = newNode
            size += 1
            
            return true
        }

        while data >= cur!.data {
            if cur!.data == data {
                return false
            }
            if cur! == head {
                break
            }
            pre = cur!
            cur = cur!.next!
        }
        
        let newNode = Node(data, cur!, pre)
        pre.next = newNode
        cur!.prev = newNode
        size += 1
        
        return true
    }
    
    mutating func remove(_ target: T) -> Bool {
        var cur = head.next
        var pre = head
        var check = false
        
        for _ in 0..<size {
            if cur!.data == target {
                check = true
                break
            }
            pre = cur!
            cur = cur!.next
        }
        
        if !check {
            return false
        }
        
        pre.next = cur!.next
        cur!.next!.prev = pre
        size -= 1
        
        return true
    }
    
    func printAt(_ data: T) -> Bool {
        var str = ""
        var cur = head.next

        while data != cur!.data {
            cur = cur!.next
            if cur! == head {
                return false
            }
        }
        
        for i in 0..<size{
            str += i == size - 1 ? "\(cur!.data)" : "\(cur!.data)\n"
            cur = cur!.next
            if cur! == head {
                cur = head.next
            }
        }
        Swift.print(str)
        return true
    }
    
    func reverse() {
        var str = ""
        var cur = head.prev
        
        for i in 0..<size{
            str += i == size - 1 ? "\(cur!.data)" : "\(cur!.data)\n"
            cur = cur!.prev
        }
        return Swift.print(str)
    }
    
    var description: String {
        var str = ""
        var cur = head.next
        
        for i in 0..<size{
            str += i == size - 1 ? "\(cur!.data)" : "\(cur!.data)\n"
            cur = cur!.next
        }
        return str
    }
}

func solution() {
    var list = CircularLinkedList<Student>(head: Node(Student(name: "", id: "")))
    
    let fileManager: FileManager = FileManager.default
    let documentPath: URL = fileManager.urls(for: .documentDirectory, in: .userDomainMask)[0]
    let directoryPath: URL = documentPath.appendingPathComponent("ìƒˆ í´ë”")
    let textPath: URL = directoryPath.appendingPathComponent("std.txt")
    
    do {
        let dataFromPath: Data = try Data(contentsOf: textPath)
        let data: String = String(data: dataFromPath, encoding: .utf8) ?? "ë¬¸ì„œì—†ìŒ"
        let dataArr = data.components(separatedBy: "\n")
        
        for data in dataArr {
            let studentArr = data.components(separatedBy: " ")
            if !list.insert(Student(name: studentArr[1], id: studentArr[0])) {
                print("ë™ì¼í•œ í•™ë²ˆì´ ì¡´ì¬í•˜ì—¬ ì…ë ¥í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")
            }
        }
    } catch let e {
        print(e.localizedDescription)
    }
    
loop:
    while true {
        print("""
              ===============================
              (1) ìƒˆ í•™ìƒ ì…ë ¥
              (2) í•™ìƒ ì‚­ì œ
              (3) í•™ë²ˆ ìˆœìœ¼ë¡œ ì „ì²´ ì¶œë ¥
              (4) í•™ë²ˆ ì—­ìˆœìœ¼ë¡œ ì „ì²´ ì¶œë ¥
              (5) íŠ¹ì • í•™ë²ˆë¶€í„° ì „ì²´ ì¶œë ¥
              (6) íŒŒì¼ì— ì €ì¥í•˜ê³  ì¢…ë£Œ
              ===============================
              """)
        print("ì›í•˜ëŠ” ê¸°ëŠ¥ì„ ì„ íƒí•˜ì„¸ìš” : ", terminator: "")
        let menu = Int(readLine()!)!
        
        
        switch(menu) {
            
        case 1:// insert
            print("í•™ë²ˆê³¼ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš” : ", terminator: "")
            let studentArr = readLine()!.components(separatedBy: " ")
            if !list.insert(Student(name: studentArr[1], id: studentArr[0])) {
                print("ë™ì¼í•œ í•™ë²ˆì´ ì¡´ì¬í•˜ì—¬ ì…ë ¥í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")
            }
            
            break
            
        case 2:// delete
            print("í•™ë²ˆì„ ì…ë ¥í•˜ì„¸ìš” : ", terminator: "")
            let id = readLine()!
            if !list.remove(Student(name: "", id: id)) {
                print("í•´ë‹¹ í•™ë²ˆì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")
            }
            break
            
        case 3:
            print(list)
            break
            
        case 4:
            list.reverse()
            break
            
        case 5:
            print("í•™ë²ˆì„ ì…ë ¥í•˜ì„¸ìš” : ", terminator: "")
            let id = readLine()!
            if !list.printAt(Student(name: "", id: id)) {
                print("í•´ë‹¹ í•™ë²ˆì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")
            }
            
        case 6:
            do {
                try fileManager.createDirectory(at: directoryPath, withIntermediateDirectories: false, attributes: nil)
            } catch let e {
                print(e.localizedDescription)
            }
            
            if let data: Data = list.description.data(using: String.Encoding.utf8) {
                do {
                    try data.write(to: textPath)
                } catch let e {
                    print(e.localizedDescription)
                }
            }
            
            print("ì¢…ë£Œí•©ë‹ˆë‹¤")
            break loop
            
        default:
            break
        }
    }
}

solution()
```

- ë°°ìš´ì 
  : next, prev ìê¸° ìì‹  ê°€ë¦¬í‚¤ê²Œ ìƒì„±ì ì‘ì„±

<br/>

[^footnote]: The footnote source
[^fn-nth-2]: The 2nd footnote source
