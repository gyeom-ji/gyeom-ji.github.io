---
title: "가상 메모리"
author: gyeomji
date: 2024-05-27 10:00:00 +0900
categories: [Operating System]
tags: [Virtual Memory]
pin: false
math: true
mermaid: true
---

<br/> 

## 가상 메모리의 필요성

---

초창기 컴퓨터는 메인 메모리의 크기가 실행하고자 하는 프로그램보다 커야했다. CPU가 오직 RAM(메인 메모리)과 소통하기 때문이다. 프로그램 전체를 RAM에 올리는 것은 쉽지않다. 컴퓨터의 사양이 각각 다르기 때문에 모든 컴퓨터에서 작동하는 프로그램을 만드는 것이 어렵고, <span style="color:#9fb584">**비용적인 측면**</span>에서도 부담이 크기 때문이다. 이를 해결하기 위해 오버레이 기법(애플리케이션의 일부만 RAM에 올리는 방법)을 개발하기도 했지만, 결국 시스템이 애플리케이션을 위한 충분한 공간을 가지고 있어야 했기 때문에 해결책이 되진 못했다. <span style="color:#9fb584">**용량 한계의 문제점**</span> 말고도 실제 메모리에서 작업을 하던 도중 발생하는 오류들을 해결하는 방식에도 위험이 있다. 메인 메모리에 직접 접근하여 작업 하던 중 오류가 발생하면 해당 부분을 한동안 사용할 수 없는 문제가 생기기 때문이다. 이에 대한 해결책으로 가상 메모리 기법이 개발되었고, 가상 메모리 기법의 필요성은 아래와 같다.<br/> 

### 1. 메인 메모리 효율적 사용

 가상 메모리는 각 프로그램이 사용하는 가상 주소 공간을 디스크에 저장하고, 자주 사용되는 부분만 메인 메모리로 가져와 사용한다. 즉, <span style="color:#9fb584">**메인 메모리를 디스크의 캐시로 사용하기 때문에, 하나의 메인 메모리에 여러 프로그램의 데이터와 코드를 적재하는 것이 가능**</span>해진다.

<br/> 

### 2. 메모리 관리 단순화

 가상 메모리는 각 프로세스마다 통일된 가상 주소 공간(상대 주소)를 배정한다. 실제 메모리 참조를 수행할 때 가상 주소를 물리 주소로 변환하기 때문이다. (MMU) 따라서 <span style="color:#9fb584">**각각의 프로세스에게 독립적인 공간을 가질 수 있게한다.**</span> 이는 링커 및 로더의 구현과 메모리 할당 방식 등을 단순화한다.

> CPU는 프로세스의 페이지 테이블을 참조하여 가상 주소를 기반으로 offset 값을 대입시켜 프로세스의 실제 주소인 물리 주소를 참조한다.<br/> A 프로세스의 가상 주소가 Ox1000 라고 한다면, CPU는 A 프로세스의 페이지 테이블을 사용해 실 주소인 Ox4000 이라는 물리 주소를 참조할 수 있게 된다.<br/> B 프로세스의 가상 주소도 Ox1000 라고 한다면, B 프로세스의 페이지 테이블을 사용해 실 주소 Ox6000을 참조할 수 있다.<br/> 두 프로세스는 동일한 가상 주소를 참조했지만, 실제로는 MMU가 페이지 테이블을 참조해서 실제 메모리 주소를 얻고 그 위치를 참조해 값을 가져오게 된다.<br/> 두 프로세스의 주소 공간이 겹치지 않으면서 같은 가상 주소를 사용하기 때문에, 프로그래머는 다른 프로세스를 관리해도 하나의 가상 주소(상대 주소)만 가지고 있으면 된다.

<br/> 

### 3. 메모리 보호 단순화

 가상 메모리는 <span style="color:#9fb584">**한 프로세스가 다른 프로세스의 주소 공간에 접근하는 것을 보호**</span>할 수 있다. 또한 가상 주소를 물리 주소로 변환할 때 참조하는 페이지 테이블의 각 엔트리에는 해당 가상 주소에 대한 <span style="color:#9fb584">**접근 권한**</span>이 명시된다. 따라서 허용되지 않은 주소 공간에 접근하는 것을 쉽게 막을 수 있다.

<br/> 
<br/> 

## 가상 메모리란

---

<span style="color:#9fb584">**CPU는 프로그램을 실행하기 위해 RAM을 사용**</span>하는데, 이 <span style="color:#9fb584">**RAM의 한정된 공간을 극복하기 위해 하드디스크의 일부 영역을 주 기억장치(메인 메모리)로 사용(Swapping)**</span>하며 (= 스왑 공간 Swap Space), 주 기억장치와 보조 기억장치 사이에서 <span style="color:#9fb584">**페이지**</span>라고 불리는 데이터 블록을 옮기는 작업을 반복함으로써 <span style="color:#9fb584">**실제보다 큰 주기억장치가 있는 것처럼 기능**</span>하게 만든다. 이로 인해 <span style="color:#9fb584">**물리적 메모리의 한계에도 불구하고 더 많은 양을 가진 프로그램들을 실행**</span>시킬 수 있다.

> Swapping : 주기억장치와 가상메모리 장치 사이의 데이터를 교환하는 기법이다.<br/> 물리 메모리가 꽉 찬 상태에서 페이지 부재가 발생했을 때 발생하며, 물리 메모리 상에서 가장 필요없는 페이지를 하드디스크로 내리고(swap-out) 그 공간에 요청한(부재) 페이지를 하드디스크에서 올려준다.(swap-in)

<br/> 

가상 메모리는 <span style="color:#9fb584">**시스템이 프로그램을 실행하기 위한 최소한 얼마만큼의 메모리가 필요한가에 대한 접근 방식**</span>으로, 실행에 필요한 일부분만 메모리에 로드하고 나머지는 디스크에 둔 후 필요할 때 교체하며 쓰는 방식으로 구현된다.


CPU는 프로그램을 실행하며 명령을 수행할 때 가상 메모리에 접근하기 위하여 MMU를 사용한다. <span style="color:#9fb584">**CPU는 가상 주소, 메모리는 물리 주소를 사용하기 때문에 MMU가 주소를 매핑하는 역할을 수행**</span>한다. 모든 메모리를 매핑하는 것은 비효율적이기 때문에 MMU는 메인 메모리를 페이지 단위로 나눠 각 페이지를 독립적으로 처리한다. 또한 <span style="color:#9fb584">**메인 메모리에는 필요한 페이지만 올려두는**</span>데 이 방식을 <span style="color:#9fb584">**요구 페이징 Demand Paging**</span> 이라 한다. 모든 데이터는 보조 기억장치에 존재하고, 필요할 때만 메인 메모리에 페이지를 올린다. 단순히 메인 메모리의 공간이 부족하다고 보조 기억장치까지 확장하여 사용하는 것이 아니다. 유효 비트를 사용하여 페이지 <span style="color:#9fb584">**적재 여부**</span>를 표시한다. 적재 되지 않은 페이지 참조를 `페이지 부재 Page Fault`라고 한다. 프로그램은 한동안 특정 부분이 집중적으로 참조(<span style="color:#9fb584">**참조 지역성**</span>)되는 특징을 가지고 있기 때문에 요구 페이징 성능이 좋다.

<br/> 
<br/> 


## 가상 메모리의 장점

---

- 메인 메모리를 하드 디스크의 캐시로 처리하여 <span style="color:#9fb584">**더 넓은 메모리 공간을 제공**</span>한다.
- 프로그램 실행에 필요한 최소 크기의 메모리만 올라가져 있다.
  - <span style="color:#9fb584">**더 많은 프로그램을 동시 수행**</span> 할 수 있다.
  - <span style="color:#9fb584">**CPU 이용률, 처리량이 증가**</span>한다.
- 페이지 공유가 가능하기 때문에, 프로그램이 이미 적재된 페이지를 접근할 경우 <span style="color:#9fb584">**메모리를 효율적으로 사용**</span>할 수 있다. 
- 프로그램이 다른 프로그램의 <span style="color:#9fb584">**영역을 접근하는 것을 보호**</span>할 수 있다.
- 메모리 <span style="color:#9fb584">**관리가 용이**</span>하다.
  - OS는 메모리 페이지 사용여부를 지속적으로 추적하여, 사용할 수 있는 공간이 남아있어도 일정 시간 쓰이지 않은 메모리 페이지를 스왑 공간으로 복사한다.
  - 어떤 프로그램이 스왑 아웃된 메모리 페이지에 접근하려할 경우, OS는 다른 메모리 페이지를 스왑 아웃하여 공간을 확보한 뒤, 요청받은 페이지를 스왑 공간으로부터 물리적 메모리로 스왑 인 한다.


<br/> 
<br/> 


## 가상 메모리 메커니즘 - 페이징 시스템

---

크기가 동일한 페이지로 가상 주소 공간과 매칭하는 물리 주소 공간을 관리한다. Demand Paging 방식을 사용하기 때문에 프로세스가 실행될 때 `필요한 공간`만 적재시켜 실행시키고, 적재가 안된 부분을 실행해야할 경우 그때 메모리에 적재시켜 실행한다. `공간`을 페이지 단위로 나눠 메모리에 적재시키고 프로세스를 실행시켜 물리 메모리를 효율적으로 사용한다. 이 페이지를 관리하는 시스템을 페이징 시스템이라 한다.

- 프로세스는 동일한 물리 주소를 가리킬 수 있다. 
  - 실행 중인 프로세스들이 동일한 로직을 수행할 경우 따로 메모리에 적재되어 실행되는 것이 아닌 동일한 공간에서 프로세스를 수행하는 것이다. 
  - 동일한 로직의 프로세스가 read만 수행한다면 따로 메모리 공간을 할당 시킬 필요가 없어 공간, 메모리 할당 시간을 절약할 수 있다.
  - 특정 프로세스에서 write를 수행하여 물리 주소에서 데이터가 변경되면 두 프로세스는 서로 다른 로직을 수행한다.
  - 이때 물리 주소 복사를 수행하여 필요할 때만 공간 할당을 수행하여 효율성을 높인다. (copy-on-write)


<br/> 
<br/> 

## 가상 메모리의 동작 과정

---

1. 프로그램의 실행
    - CPU는 해당 프로그램의 명령어를 순차적으로 가져와 명령을 실행한다. 이 때 프로그램은 메모리의 실 주소를 사용하는 것이 아니라 <span style="color:#9fb584">**가상 주소 logical address를 사용**</span>한다.
2. 주소 번역
    - 프로그램이 가상 주소를 사용하여 메모리에 접근하면, <span style="color:#9fb584">**CPU는 MMU에게 가상 주소를 전달한다. MMU는 가상 주소를 페이지 테이블을 통해 실제 주소(물리 주소)로 변환**</span>한다.
3. 실 주소에 접근
    - 변환된 <span style="color:#9fb584">**실 주소를 기반으로 CPU는 메인 메모리에 접근**</span>한다. 이 때 필요한 페이지가 메인 메모리에 있는 경우와 없는 경우로 나뉜다. 필요한 페이지만 메인 메모리에 올려두는 Demand paging 방식을 사용하기 때문이다. Demand paging은 페이지 테이블에서 해당 페이지가 메모리에 있는지 나타내는 유/무효 비트(valid/invalid bit)를 사용한다. 비트가 유효인 경우(필요한 페이지가 메인 메모리에 존재하는 경우) 그대로 사용한다.
4. 비트가 무효인 경우 (페이지가 메인 메모리에 없는 경우)
    - 필요한 페이지가 메인 메모리에 없다면 `페이지 부재 Page Fault`가 발생한다. 이 상황이 발생하면 <span style="color:#9fb584">**MMU가 인터럽트 (페이지 부재 트랩)를 발생**</span>시킨다. 이후 OS가 해당 <span style="color:#9fb584">**프로세스를 잠시 대기 상태**</span>로 만들고 보조 기억장치에서 페이지를 메인 메모리의 <span style="color:#9fb584">**빈 공간에 적재하고, 페이지 테이블을 갱신**</span>한다. 갱신 완료 시 해당 프로세스의 <span style="color:#9fb584">**대기 상태를 해제하고, 명령을 다시 실행**</span>한다. 메모리에 공간이 부족한 경우 [페이지 교체 기법](https://gyeom-ji.github.io/posts/pageFaultAlgorithm/)을 사용하여 메모리 공간을 확보한다.

<br/> 
<br/> 

## 가상 메모리와 물리 메모리의 차이

---

| |가상 메모리|물리 메모리|
|:------:|:------:|:------:|
|최대 메모리 크기|CPU의 비트 값에 의존|CPU의 비트 값에 의존|
|메모리 분할 방식|세그먼테이션, 페이징, 페이징/세그먼테이션 혼용|가변분할, 고정분할|
|주소 지정 방식|가상주소|절대주소, 상대 주소|

<br/>


<br/> 

[^footnote]: The footnote source
[^fn-nth-2]: The 2nd footnote source
