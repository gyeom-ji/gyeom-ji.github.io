---
title: "가상 메모리"
author: gyeomji
date: 2024-05-27 10:00:00 +0900
categories: [Operating System]
tags: [Virtual Memory]
pin: false
math: true
mermaid: true
---

<br/> 

## 가상 메모리의 필요성

---

초창기 컴퓨터는 메인 메모리의 크기가 실행하고자 하는 프로그램보다 커야했다. CPU가 오직 RAM(메인 메모리)과 소통하기 때문이다. 프로그램 전체를 RAM에 올리는 것은 쉽지않다. 컴퓨터의 사양이 각각 다르기 때문에 모든 컴퓨터에서 작동하는 프로그램을 만드는 것이 어렵고, <span style="color:#9fb584">**비용적인 측면**</span>에서도 부담이 크기 때문이다. 이를 해결하기 위해 오버레이 기법(애플리케이션의 일부만 RAM에 올리는 방법)을 개발하기도 했지만, 결국 시스템이 애플리케이션을 위한 충분한 공간을 가지고 있어야 했기 때문에 해결책이 되진 못했다. <span style="color:#9fb584">**용량 한계의 문제점**</span> 말고도 실제 메모리에서 작업을 하던 도중 발생하는 오류들을 해결하는 방식에도 위험이 있다. 메인 메모리에 직접 접근하여 작업 하던 중 오류가 발생하면 해당 부분을 한동안 사용할 수 없는 문제가 생기기 때문이다. 이에 대한 해결책으로 가상 메모리 기법이 개발되었고, 가상 메모리 기법의 필요성은 아래와 같다.<br/> 

### 1. 메인 메모리 효율적 사용

 가상 메모리는 각 프로그램이 사용하는 가상 주소 공간을 디스크에 저장하고, 자주 사용되는 부분만 메인 메모리로 가져와 사용한다. 즉, <span style="color:#9fb584">**메인 메모리를 디스크의 캐시로 사용하기 때문에, 하나의 메인 메모리에 여러 프로그램의 데이터와 코드를 적재하는 것이 가능**</span>해진다.

<br/> 

### 2. 메모리 관리 단순화

 가상 메모리는 각 프로세스마다 통일된 가상 주소 공간(상대 주소)를 배정한다. 실제 메모리 참조를 수행할 때 가상 주소를 물리 주소로 변환하기 때문이다. (MMU) 따라서 <span style="color:#9fb584">**각각의 프로세스에게 독립적인 공간을 가질 수 있게한다.**</span> 이는 링커 및 로더의 구현과 메모리 할당 방식 등을 단순화한다.

> CPU는 프로세스의 페이지 테이블을 참조하여 가상 주소를 기반으로 offset 값을 대입시켜 프로세스의 실제 주소인 물리 주소를 참조한다.<br/> A 프로세스의 가상 주소가 Ox1000 라고 한다면, CPU는 A 프로세스의 페이지 테이블을 사용해 실 주소인 Ox4000 이라는 물리 주소를 참조할 수 있게 된다.<br/> B 프로세스의 가상 주소도 Ox1000 라고 한다면, B 프로세스의 페이지 테이블을 사용해 실 주소 Ox6000을 참조할 수 있다.<br/> 두 프로세스는 동일한 가상 주소를 참조했지만, 실제로는 MMU가 페이지 테이블을 참조해서 실제 메모리 주소를 얻고 그 위치를 참조해 값을 가져오게 된다.<br/> 두 프로세스의 주소 공간이 겹치지 않으면서 같은 가상 주소를 사용하기 때문에, 프로그래머는 다른 프로세스를 관리해도 하나의 가상 주소(상대 주소)만 가지고 있으면 된다.

<br/> 

### 3. 메모리 보호 단순화

 가상 메모리는 <span style="color:#9fb584">**한 프로세스가 다른 프로세스의 주소 공간에 접근하는 것을 보호**</span>할 수 있다. 또한 가상 주소를 물리 주소로 변환할 때 참조하는 페이지 테이블의 각 엔트리에는 해당 가상 주소에 대한 <span style="color:#9fb584">**접근 권한**</span>이 명시된다. 따라서 허용되지 않은 주소 공간에 접근하는 것을 쉽게 막을 수 있다.

<br/> 
<br/> 


## 가상 메모리란

---

- 프로그램을 <span style="color:#9fb584">**일부만 메모리에 적재하고도 실행이 가능**</span>하게 하는 기법이다.
- CPU는 프로그램을 실행하기 위해 RAM을 사용하는데, RAM의 한정된 공간을 극복하기 위해 하드디스크의 일부 영역을 주 기억장치(메인 메모리)로 사용한다.(= 스왑 공간 Swap Space)
- 주 기억장치와 보조 기억장치 사이에서 <span style="color:#9fb584">**페이지**</span>라고 불리는 데이터 블록을 옮기는 작업을 반복함으로써 <span style="color:#9fb584">**실제보다 큰 주기억장치가 있는 것처럼 기능**</span>하게 만든다. 
- <span style="color:#9fb584">**물리적 메모리의 한계에도 불구하고 더 많은 양을 가진 프로그램들을 실행**</span>시킬 수 있다.
- 가상 메모리는 <span style="color:#9fb584">**시스템이 프로그램을 실행하기 위한 최소한 얼마만큼의 메모리가 필요한가**</span>에 대한 접근 방식이다.
- 실행에 필요한 일부분만 메모리에 로드하고 나머지는 디스크에 둔 후 필요할 때 교체하며 쓰는 방식으로 구현된다.
- CPU는 프로그램을 실행하며 명령을 수행할 때 가상 메모리에 접근하기 위하여 MMU를 사용한다.
  - <span style="color:#9fb584">**CPU는 가상 주소, 메모리는 물리 주소를 사용하기 때문에 MMU가 주소를 매핑하는 역할을 수행**</span>한다.
  - 모든 메모리를 매핑하는 것은 비효율적이기 때문에 MMU는 메인 메모리를 페이지 단위로 나눠 각 페이지를 독립적으로 처리한다.
- <span style="color:#9fb584">**메인 메모리에는 필요한 페이지만 올려두는**</span>데 이 방식을 <span style="color:#9fb584">**요구 페이징 Demand Paging**</span> 이라 한다.
  - 모든 데이터는 보조 기억장치에 존재하고, 필요할 때만 메인 메모리에 페이지를 올린다.
  - 단순히 메인 메모리의 공간이 부족하다고 보조 기억장치까지 확장하여 사용하는 것이 아니다.


<br/> 
<br/> 


## 가상 메모리의 장점

---

- 메인 메모리를 하드 디스크의 캐시로 처리하여 <span style="color:#9fb584">**더 넓은 메모리 공간을 제공**</span>한다.
- 프로그램 실행에 필요한 최소 크기의 메모리만 올라가져 있다.
  - <span style="color:#9fb584">**Multiprogramming 정도가 증가**</span>힌다.
  - <span style="color:#9fb584">**CPU 이용률, 처리량이 증가**</span>한다.
- 페이지 공유가 가능하기 때문에, 프로그램이 이미 적재된 페이지를 접근할 경우 <span style="color:#9fb584">**메모리를 효율적으로 사용**</span>할 수 있다.
  - 프로세스 생성 시간을 단축할 수 있다.
- 스와핑 시간이 줄어들어 더 빠른 실행(Turnaround Time ⬇️)이 가능하다
- 프로그램이 다른 프로그램의 <span style="color:#9fb584">**영역을 접근하는 것을 보호**</span>할 수 있다.
- 메모리 <span style="color:#9fb584">**관리가 용이**</span>하다.
  - OS는 메모리 페이지 사용여부를 지속적으로 추적하여, 사용할 수 있는 공간이 남아있어도 일정 시간 쓰이지 않은 메모리 페이지를 스왑 공간으로 복사한다.
  - 어떤 프로그램이 스왑 아웃된 메모리 페이지에 접근하려할 경우, OS는 다른 메모리 페이지를 스왑 아웃하여 공간을 확보한 뒤, 요청받은 페이지를 스왑 공간으로부터 물리적 메모리로 스왑 인 한다.


<br/> 
<br/> 


## 요구 페이징 Demand Paging

---

- page가 실제 필요(요구)할 때 메모리에 적재한다.
- 유효 비트를 사용하여 페이지 테이블에 페이지 <span style="color:#9fb584">**적재 여부**</span>를 표시한다.
  - valid/invalid bit
- 적재 되지 않은 페이지 참조를 `페이지 부재 Page Fault`라고 한다.
  - MMU가 유효비트를 검사하고, invalid인 경우 page fault trap이 발생한다.
- 프로그램은 한 동안 특정 부분이 집중적으로 참조(<span style="color:#9fb584">**참조 지역성**</span>)되는 특징을 가지고 있다.
  - 요구 페이징 성능이 상당히 좋다.

<br/> 

> Swapping VS Demanding Paging<br/>
> Swapping과 Demanding Paging은 메모리와 Swap space 사이를 오고 가는 기능을 수행한다.<br/>
> Swapping은 프로세스 단위로 이동하고 Demanding Paging은 페이지 단위로 swapping한다.

<br/> 

### 요구 페이징 처리 단계와 성능

1. trap to OS
2. 현재 프로세스 p1의 context를 보존한다.
3. 인터럽트 원인이 page fault임을 확인한다.
4. 디스크 내 페이지 위치를 파악한다.
5. 디스크에서 free frame으로 읽기를 요청한다.(대기하는 동안 CPU를 다른 프로세스 p2에게 할당)
   1. 디스크 대기 큐에서 기다린다.
   2. Seek Time(탐색 시간), Latency Time(지연 시간)
   3. 페이지를 frame으로 이동한다.
6. read완료 인터럽트를 수신한다.
7. 프로세스 p2의 context를 보존한다.
8. page table을 갱신하고 dispatching 될 때까지 대기한다.
9. 프로세스 p1의 context를 복원하고 실행을 재계한다.

<br/> 

### 유효 접근 시간 Effective Access Time

`(1 - 페이지 부재율) × 메모리 접근 시간 + 페이지 부재율 × 페이지 부재 시간`

- 페이지 부재 시간 = interrupt service 시간 + page read 시간 + process restart 시간 ≈ page read 시간
- 메모리 접근 시간 = 보통 10ns ~ 200ns 
- page read 시간 = 보통 8ms
- 유효 접근 시간은 페이지 부재율에 비례한다.
- 페이지 부재가 매우 적은 확률로 발생해야 효율적이다.
  - 지역성의 원리로 인해 페이지 부재 확률은 매우 낮다.
  > 지역성의 원리 Locality Of Reference : 메모리 접근은 시간적 지역성과 공간적 지역성을 가진다.<br/> 
  > 시간적 지역성 : CPU 는 어느 메모리 공간을 읽은 후 시간이 지나도 그 공간을 다시 읽을 확률이 매우 높다는 것을 말한다. (반복문은 하나의 코드 공간을 여러번 읽는다)<br/> 
  > 공간적 지역성 : CPU 가 메모리 공간을 읽을 때는 인접한 범위 내에서 읽는다는 것을 말한다.(프로그램은 대부분 절차적인 순서로 구현되어 있어 순서대로 읽는 경우가 빈번하다)

<br/> 

### Page Fault에 영향을 주는 요소

1. [페이지 교체 알고리즘](https://gyeom-ji.github.io/posts/pageFaultAlgorithm/)
  - 페이지 부재율 낮은 알고리즘이 좋다.
  - 페이지 부재 횟수 : 교체 알고리즘 별 페이지 부재 횟수 * 참조 스트링 
2. [프레임 할당 알고리즘](https://gyeom-ji.github.io/posts/frame/)
  - 프로세스에게 프레임을 할당하는 숫자(방법)에 따라 페이지 부재율이 영향을 받는다.
  - 보통 프레임이 많을수록 페이지 부재율이 낮다.


<br/> 
<br/> 

## 가상 메모리의 동작 과정

---

1. 프로그램의 실행
    - CPU는 해당 프로그램의 명령어를 순차적으로 가져와 명령을 실행한다. 
    - 이 때 프로그램은 메모리의 실 주소를 사용하는 것이 아니라 <span style="color:#9fb584">**가상 주소 logical address를 사용**</span>한다.
2. 주소 번역
    - 프로그램이 가상 주소를 사용하여 메모리에 접근하면, <span style="color:#9fb584">**CPU는 MMU에게 가상 주소를 전달한다.**</span>
    - <span style="color:#9fb584">**MMU는 가상 주소를 페이지 테이블을 통해 실제 주소(물리 주소)로 변환**</span>한다.
3. 실 주소에 접근
    - 변환된 <span style="color:#9fb584">**실 주소를 기반으로 CPU는 메인 메모리에 접근**</span>한다.
    - 이 때 필요한 페이지가 메인 메모리에 있는 경우와 없는 경우로 나뉜다. 
      - 필요한 페이지만 메인 메모리에 올려두는 Demand paging 방식을 사용하기 때문이다. 
      - Demand paging은 페이지 테이블에서 해당 페이지가 메모리에 있는지 나타내는 유/무효 비트(valid/invalid bit)를 사용한다. 
    - 비트가 유효인 경우(필요한 페이지가 메인 메모리에 존재하는 경우) 그대로 사용한다.
4. 비트가 무효인 경우 (페이지가 메인 메모리에 없는 경우)
    - 필요한 페이지가 메인 메모리에 없다면 `페이지 부재 Page Fault`가 발생한다. 
    - 이 상황이 발생하면 <span style="color:#9fb584">**MMU가 인터럽트 (페이지 부재 트랩)를 발생**</span>시킨다. 
    - 이후 OS가 해당 <span style="color:#9fb584">**프로세스를 잠시 대기 상태**</span>로 만들고 보조 기억장치에서 페이지를 메인 메모리의 <span style="color:#9fb584">**빈 공간에 적재하고, 페이지 테이블을 갱신**</span>한다. 
    - 갱신 완료 시 해당 프로세스의 <span style="color:#9fb584">**대기 상태를 해제하고, 명령을 다시 실행**</span>한다.
    - 메모리에 공간이 부족한 경우 [페이지 교체 알고리즘](https://gyeom-ji.github.io/posts/pageFaultAlgorithm/)을 사용하여 메모리 공간을 확보한다.

<br/> 
<br/> 

## 가상 메모리와 물리 메모리의 차이

---

| |가상 메모리|물리 메모리|
|:------:|:------:|:------:|
|최대 메모리 크기|CPU의 비트 값에 의존|CPU의 비트 값에 의존|
|메모리 분할 방식|세그먼테이션, 페이징, 페이징/세그먼테이션 혼용|가변분할, 고정분할|
|주소 지정 방식|가상주소|절대주소, 상대 주소|

<br/>


<br/> 

[^footnote]: The footnote source
[^fn-nth-2]: The 2nd footnote source
