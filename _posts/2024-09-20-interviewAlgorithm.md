---
title: "iOS 면접 준비 - 알고리즘"
author: gyeomji
date: 2024-09-20 10:00:00 +0900
categories: [Interview]
tags: [알고리즘]
pin: false
math: true
mermaid: true
---

## ✏️ 알고리즘의 시간 복잡도와 공간 복잡도의 개념, 그리고 빅오 표기법

---

- 복잡도란 알고리즘의 성능과 효율성을 나타내는 척도이다.
- 각 알고리즘이 주어진 특정 크기의 입력(n)을 기준으로 수행시간(연산) 혹은 사용공간이 얼마나 되는지 객관적으로 비교할 수 있는 기준을 제시한다.

<br/>

### 시간 복잡도

- 프로그램을 실행시켜 완료하는데 필요한 CPU 시간이다.
- 총 시간 = 컴파일 시간 + 실행 시간
- 컴파일 시간 : 고정 시간을 요구한다.
- 실행 시간 : 입출력의 크기에 따라 변동되므로 <span style="color:#9fb584">**기본적인 연산 횟수를 입력 크기의 함수로 표현**</span>한다.
  - 기본 연산 : 데이터 간 크기 비교, 데이터 읽기, 갱신, 숫자 계산 등과 같은 단순한 연산
  - 함수는 다항식으로 표현되며, 이를 입력 크기에 대한 함수로 표현하기 위해 `점근표기법`을 사용한다.
  - `점근표기법` : 중요하지 않은 상수와 계수들을 제거하고 가장 큰 영향을 주는 항만 계산한다.

#### 점근표기법 종류

- `O(Big-Oh) 표기법` : 최악의 경우
- `θ(Theta) 표기법` : 평균의 경우
- `Ω(Big-Omega) 표기법` : 최상의 경우
- 알고리즘이 복잡해질수록 평균을 구하기 어려워져 최악의 경우로 알고리즘 성능을 파악한다.
- 최악의 경우를 판단하면 평균과 가까운 성능으로 예측하기 쉽다.

<br/>

### 공간 복잡도

- 프로그램을 실행시켜 완료하는데 필요한 메모리 공간의 크기이다.
- 고정 부분과 가변 부분으로 나눌 수 있다.
- 고정 부분 : 알고리즘과 관계없는 메모리 요구량이다.
  - 코드가 저장되는 공간 (명령어 공간)
  - 단순 변수, 고정 크기의 변수를 위한 공간
  - 상수들을 저장하기 위한 공간
- 가변 부분 : 알고리즘에 따라 변동하는 메모리 요구량이다.
  - 변수, 참조된 변수가 필요로 하는 공간
  - 순환 스택 공간

<br/>

### 빅오 표기법

- 불필요한 연산을 제거하여 알고리즘 분석을 쉽게할 목적으로 사용된다.
- 입력값의 변화에 따라 연산을 실행할 때, 연산 횟수에 비해 시간이 얼마만큼 걸리는가?’를 표기하는 방법이다.
- 다항식에서 최고 차수 항만을 취한 뒤, 그 항의 계수를 제거한다.
  - $2N^2 \ + \ 3N \ + \ 5 \ = \ O(N^2)$

#### 자주 사용하는 O표기법

- `O(1)` : 상수 시간 
  - 입력에 관계 없이 복잡도가 동일하다.
  - ex) 해시 테이블
- `O(log n)` : 로그(대수) 시간 
  - 문제를 해결하는데 필요한 단계들이 연산마다 특정 요인에 의해 줄어든다.
  - ex) 이진 탐색
- `O(n)` : 선형 시간 
  - 문제를 해결하기 위한 단계의 수와 입력 값 n이 1:1 관계를 가진다.
  - 입력값에 따라 실행 시간이 정비례하게 증가한다.
  - ex) 순차 탐색
- `O(nlogn)`  : 로그 선형 시간
  - 문제를 해결하기 위한 단계의 수가 N*(log2N)번 만큼의 수행시간을 가진다.
  - ex) 합병 정렬, 퀵 정렬
- `O(n^2)` : 제곱 시간 
  - 문제를 해결하기 위한 단계의 수는 입력값 n의 제곱이다.
  - ex) 버블 정렬, 삽입 정렬
- `O(C^n)` : 지수 시간 
  - 문제를 해결하기 위한 단계의 수는 주어진 상수값 C 의 n 제곱이다.
  - ex) 피보나치 수열

<br/>

## ✏️ 자주 사용되는 정렬 알고리즘(예: 퀵 정렬, 병합 정렬)의 동작 원리와 시간 복잡도

---


| |선택 정렬|버블 정렬|삽입 정렬|쉘 정렬|힙 정렬|합병 정렬|퀵 정렬|기수 정렬|
|:------:|:------:|:------:|:------:|:------:|:------:|:------:|:------:|:------:|
|평균|O(n^2)|O(n^2)|O(n^2)|?|O(nlogn)|O(nlogn)|O(nlogn)|O(d(n+r))|
|최선|O(n^2)|O(n^2)|O(n)|O(nlogn)|O(nlogn)|O(nlogn)|O(nlogn)|O(d(n+r))|
|최악|O(n^2)|O(n^2)|O(n^2)|O(n^1.5)|O(nlogn)|O(nlogn)|O(n^2)|O(d(n+r))|
|공간 복잡도|O(1)|O(1)|O(1)|O(1)|O(1)|O(n)|O(logn) or O(N)|O(n + r)|

<br/>

- `선택 정렬` : 배열에서 아직 정렬되지 않은 부분의 원소들 중 <span style="color:#9fb584">**최솟값을 선택하여 정렬된 부분의 바로 오른쪽 원소와 교환**</span>한다.
  - 입력에 민감하지 않아 항상 같은 수행시간을 가진다.
- `버블 정렬` : <span style="color:#9fb584">**인접한 두 원소를 검사하여 교환**</span>한다.
  - 순회를 한 번 마칠 때마다 비교 대상이 하나씩 줄어든다.
- `삽입 정렬` : 배열이 정렬된 부분과 정렬되지 않은 부분으로 나뉘며, <span style="color:#9fb584">**정렬 안된 부분의 가장 왼쪽 원소를 정렬된 부분에 삽입**</span>한다.
  - 입력이 이미 정렬된 경우 (최선) O(n)
  - 입력이 역으로 정렬된 경우 (최악) O(n^2)
  - 입력 데이터 순서가 랜덤인 경우 (평균) O(n^2)
  - 이미 정렬된 데이터의 뒷부분에 소량의 데이터를 추가하여 정렬하는 경우 성능이 우수하다. 
  - 입력 데이터의 크기가 작은 경우에도 좋은 성능을 가진다.
  - 합병 정렬, 퀵 정렬과 함께 사용되어 실질적으로 빠른 성능에 도움을 준다.
- `쉘 정렬` : <span style="color:#9fb584">**삽입 정렬에 전처리 과정을 추가**</span>한 정렬 알고리즘이다.
  - 전처리 과정 : 작은 값을 가진 원소들을 배열의 앞부분으로 옮기며 큰 값을 가진 원소들이 배열의 뒷부분에 자리잡도록 만드는 과정
  - 전처리 과정(h-정렬)은 여러 단계로 진행되며, 각 단계에서는 일정 간격으로 떨어진 원소들에 대해 삽입 정렬을 수행 한다.
  - `h-정렬` : 간격이 h인 원소들끼리 정렬하는 것
  - 쉘 정렬은 h-정렬의 h 값을 줄여가며 정렬을 수행하고, 마지막엔 간격을 1로 하여 정렬한다.
    - h = 1 인 경우 삽입 정렬과 동일하다.
  - 입력이 크지 않은 경우 매우 좋은 성능을 보인다.
- `힙 정렬` : 힙 자료구조를 이용한다.
  - <span style="color:#9fb584">**상향식으로 최대 힙을 구성**</span>한다.
  - <span style="color:#9fb584">**루트노드의 값을 힙의 가장 마지막 노드 값과 교환한 후 힙 크기를 1 감소**</span>시킨다.
  - 이동으로 인해 <span style="color:#9fb584">**위배된 힙 속성을 `downheap`연산으로 복원**</span>한다.
  - 정렬이 완료될 때까지 위의 과정을 반복한다.
  - 총 수행 시간은 O(nlogn)
    - 상향식 힙 만들기 : O(n)
    - 루트와 힙 마지막 노드를 교환한 후 downHeap() 수행 : O(logn)
    - 루트와 힙 마지막 노드를 교환하는 횟수 : N - 1번
  - 루프 내의 코드가 길고, 비효율적인 캐시 메모리를 사용하기 때문에 대용량의 입력을 정렬하기에는 부적절하다.
- `합병 정렬` : 크기가 N인 입력을 1/2크기를 가지는 <span style="color:#9fb584">**입력 2개로 분할하고, 각각 재귀적으로 합병 정렬을 수행한 후, 2개의 정렬된 부분을 합병**</span>한다.
  - 합병 정렬의 성능 향상 방법
    - 합병 정렬은 재귀호출을 사용하므로 입력 크기가 1이 되어야 합병을 시작한다.
    - 입력이 정해진 크기가 되면 `삽입 정렬`을 통해 정렬한 후 합병을 수행하면 이 문제점을 보완할 수 있다.
    - merge()에서 매번 보조배열 secondArr을 입력배열 firstArr로 복사하는데, 보조배열과 입력배열을 번갈아 사용하도록 하면 합병 정렬의 성능을 향상시킬 수 있다.
    - 합병하기 위한 두 개의 리스트가 이미 정렬되어 있다면 합병을 생략한다.
    - 모든 정렬 방식에서 실제 데이터를 이동하지 않고, 인덱스 또는 레퍼런스를 저장하는 배열에 저장된 위치만 저장하여 데이터 이동에 대한 부하를 감소시킬 수 있다.
- `퀵 정렬` : 입력의 <span style="color:#9fb584">**맨 왼쪽 원소(피벗 Pivot)를 기준으로 피벗보다 작은 원소들과 큰 원소들을 각각 피벗의 좌우로 분할한 후, 피벗보다 작은 원소들과 피벗보다 큰 원소들을 재귀적으로 정렬**</span>한다.
  - 피벗 값에 따라 분할되는 두 영역의 크기가 결정된다.
  - 평균적으로 빠른 수행시간을 가지며, 보조 배열을 사용하지 않는다.

[📝 정렬](https://gyeom-ji.github.io/posts/sort/)

<br/>

## ✏️ 이진 탐색의 원리와 시간 복잡도

---

- 정렬된 데이터에서 사용하며 데이터가 저장된 구간을 반으로 나눠 데이터가 저장된 위치를 찾는다.
  - target이 중간 값보다 크면 중간 값을 포함한 하위 값들은 탐색 대상에서 제외한다.
  - 중간 값보다 작을 경우 중간 값을 포함한 상위 값들은 탐색 대상에서 제외한다.
- 즉, 중간값과 찾으려는 값의 대소를 비교한 뒤 <span style="color:#9fb584">**탐색 범위를 반으로 줄여가며 값을 찾는 탐색 알고리즘**</span>이다.
- O(logn)
  - 중간을 기준으로 탐색 대상을 절반씩 줄여나가기 때문에 O(logn)의 시간에 값을 찾을 수 있다.

1. 정렬된 배열의 mid 와 value 비교
2. mid == value 종료
3. 탐색 범위 재설정 ( mid < data ? low ~ mid - 1 : mid + 1 ~ high)
4. mid == value 일때까지 반복

``` swift
func recursiveBinarySearch(_ arr: [Int],_ value: Int,_ start: Int,_ end: Int) -> Int {
    if start > end {
        return -1
    }
    let mid = arr.count / 2
    if arr[mid] == value { return mid }
    if arr[mid] < value {
        return recursiveBinarySearch(arr, value, mid + 1, end)
    } else {
        return recursiveBinarySearch(arr, value, start, mid - 1)
    }
}

func iterativeBinarySearch(_ arr: [Int],_ value: Int,_ start: Int,_ end: Int) -> Int {
    var start = start, end = end

    while start <= end {
        let mid = (start + end) / 2
        if arr[mid] == value { return mid }
        
        if arr[mid] < value {
            start = mid + 1
        } else {
            end = mid - 1
        }
    }
    return -1
}

```

[📝 이진 탐색](https://gyeom-ji.github.io/posts/search-algorithm/)

<br/>

## ✏️ 동적 프로그래밍(Dynamic Programming)의 개념

---

- <span style="color:#9fb584">**한 큰 문제를 여러개의 작은 문제로 쪼개 그 결과를 저장하고 큰 문제를 해결할 때 재사용**</span>하는 특정한 알고리즘이 아닌 하나의 문제 해결 패러다임이다.
- 문제를 작게 쪼개서 하위 문제를 해결하고 연계적으로 큰 문제를 헤결한다는 점은 분할 정복과 동일하지만, DP는 중복이 일어나는 경우 사용한다.
- <span style="color:#9fb584">**동일한 문제들이 여러번 반복 될 때**</span> DP를 사용하면 효율적으로 문제 해결이 가능하다.

[📝 동적 프로그래밍](https://gyeom-ji.github.io/posts/dynamic-programming/)


<br/>

## ✏️ Swift의 고차 함수(Higher-Order Functions)에 대해 설명해주세요

---

- <span style="color:#9fb584">**다른 함수를 인자로 받거나 함수 자체를 반환하는 함수**</span>이다.
- 고차 함수를 통해 코드의 간결성과 가독성을 높이며, 컬렉션을 효과적으로 조작할 수 있다.
- 주로 배열이나 딕셔너리 같은 컬렉션에서 자주 사용되며, 함수형 프로그래밍의 중요한 개념 중 하나이다.
- 장점
  - <span style="color:#9fb584">**코드 간결화**</span> : 복잡한 루프나 조건문을 줄여 직관적 코드 작성 가능
  - <span style="color:#9fb584">**불변성 유지**</span> : 원본을 수정하지 않고 새로운 컬렉션 반환
  - <span style="color:#9fb584">**함수형 프로그래밍 패러다임**</span> : 데이터 처리 로직을 간결하고 명확하게 작성

<br/>

### map

- 컬렉션의 <span style="color:#9fb584">**각 요소에 동일한 연산을 적용한 후, 그 결과를 새로운 배열로 반환**</span>한다.
- 기존 배열의 값을 변경하지 않고, 변환된 값을 기반으로 새로운 배열을 생성한다.
- 데이터를 변환할 때 유용하다.
  - 문자열 배열을 정수 배열로 변환하거나, 특정 값만을 추출할 때 사용한다.

``` swift
let nums = [1, 2, 3, 4, 5]
let str = nums.map {String($0)}
print(str) 
// ["1", "2", "3", "4", "5"]
```

<br/>

### filter

- 컬렉션의 <span style="color:#9fb584">**각 요소를 조건에 따라 필터링하여, 조건을 충족하는 요소만을 포함하는 새로운 배열을 반환**</span>한다.
- 특정 조건을 충족하는 요소만을 남기고 나머지를 제거할 때 사용한다.
  - 배열에서 짝수만 남기거나 특정 문자열이 포함된 요소를 필터링할 때 유용하다.

``` swift
let nums = [1, 2, 3, 4, 5]
let evenNums = nums.filter {$0 % 2 == 0}
print(evenNums)
// [2, 4]
```

<br/>

### reduce

- <span style="color:#9fb584">**초기값과 결합 클로저를 사용하여, 컬렉션의 각 요소를 순차적으로 결합하여 하나의 값으로 반환하고 싶을 때 사용**</span>한다.
- 최종 누적 값이 반환되며, 컨테이너의 요소가 없다면 initialResult 의 값이 반환된다.
- 배열의 값을 합산하거나 곱한 결과를 얻을 때 유용하다.
- 표현식 2 설명
  - reduce(0) : 초기값 0
  - { $0 + $1 } : 결합 클로저
    - $0 : reduce 함수의 누적 결과 (초기값 0)
    - $1 : nums 배열의 각 요소

``` swift
let nums = [1, 2, 3, 4, 5]

// 표현식 1
let sum = nums.reduce(0, +)
let product = nums.reduce(1, *)

// 표현식 2
let sum = nums.reduce(0) { $0 + $1 }

print(sum)
print(product)
// 15
// 120
```

<br/>

### compactMap

- <span style="color:#9fb584">**nil이 아닌 유효한 값만을 포함하는 배열을 반환**</span>한다.
  - 변환 과정에서 nil 발생 시 자동으로 제거한다.
- 옵셔널 배열을 필터링할 때 유용하며, 변환 과정에서 발생하는 nil 값을 제거하여 유효한 값만을 처리할 수 있다.

``` swift
let str = ["1", "2", "three", "4", "five"]
let nums = str.compactMap { Int($0) }
print(nums)
// [1, 2, 4]
```

<br/>

### flatMap

- <span style="color:#9fb584">**2차원 배열(배열의 배열)을 1차원 배열로 펼쳐 준다.**</span>
- 각 요소를 변환한 후 nil 값을 제외하고 하나의 배열로 평평하게 만든다.
- 중첩된 배열을 단순화하여 1차원 배열로 처리할 때 유용하다.

``` swift
let str = [[1, 2, 3], [4, 5], [6, 7, 8]]
let nums = str.flatMap { $0 }
print(nums)
// [1, 2, 3, 4, 5, 6, 7, 8]
```

<br/>

## ✏️ map과 flatMap의 차이점은 무엇인가요?

---

1. 변환 결과의 배열 구조
   - map은 변환된 요소를 그대로 배열에 담아 반환한다.
   - flatMap은 중첩된 배열을 평탄화하여 1차원 배열로 반환한다.
2. nil 값 처리
  - map : 옵셔널 값을 처리할 때 nil 값을 그대로 유지하므로 변환 결과 배열에 nil 값이 포함될 수 있다.
  - flatMap : 옵셔널 값에서 nil을 자동으로 제거한다.

<br/>

## ✏️ filter, reduce 함수는 어떤 경우에 사용하나요?

---

- filter : 컬렉션의 각 요소를 조건에 따라 필터링하여 새로운 배열으로 반환하고 싶을 때 사용
  - 특정 조건을 만족하는 요소만 선택할 때
  - 텍스트 검색 기능에 활용
- reduce : 초기값과 클로저를 사용하여 컬렉션의 각 요소를 순차적으로 결합하여 하나의 값으로 반환하고 싶을 때 사용
  - 합, 곱셈, 문자열 연결, 특정 기준의 최댓값 및 최솟값 계산 등 누적 계산이 필요할 때

<br/>

## ✏️ compactMap은 어떤 역할을 하나요?

---

- 옵셔널 값을 제거하고 유효한 값만을 포함하는 배열을 반환한다.
- 변환 과정에서 실패할 수 있는 값들을 다룰 때
- 옵셔널 배열에서 nil을 제거하고 유효한 값들만 필요할 때
- 중첩된 옵셔널을 제거하여 값을 평탄화할 때

<br/>
<br/>

[^footnote]: The footnote source
[^fn-nth-2]: The 2nd footnote source