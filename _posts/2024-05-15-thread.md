---
title: "스레드 Thread"
author: gyeomji
date: 2024-05-15 10:00:00 +0900
categories: [Operating System]
tags: [Thread]
pin: false
math: true
mermaid: true
---

<br/> 

## 스레드

---

- <span style="color:#9fb584">**프로세스의 실행 흐름(경로)**</span>으로써 프로세스가 할당받은 자원을 이용하는 실행의 단위이며, CPU가 처리하는 작업의 단위이다.
  - 프로세스가 생성되면 CPU 스케줄러는 프로세스가 해야 할 일(스레드)을 CPU에 전달하고 실제 작업은 CPU가 수행한다.
  - OS 입장에서 작업 단위는 프로세스이고, CPU 입장에서의 작업 단위는 스레드이다.
  - 여러 개의 스레드가 모여 프로세스를 만들고, 여러 개의 프로세스가 모여 일괄 처리하는 방법을 일괄 작업(Job)이라 한다.

<br/> 
<br/> 

## 스레드 특징

---

- 스레드는 프로세스 내부에 존재하기 때문에 프로세스의 데이터 영역에 접근이 가능하고, 스레드들끼리 서로의 데이터에 접근 가능하다.
   - 프로세스는 독립된 개체로서 생성되면 각각의 메모리 자원을 할당 받고, 서로 접근할 수 없기 때문에 IPC를 통해서 통신할 수 있다.
   - 또한 독립적인 메모리 공간으로 문맥 교환 Context Switch이 발생한다.
    > 프로세스를 여러 개 생성하는 방식은 많은 시간과 자원을 소비한다. 새 프로세스가 해야 할 일이 기존 프로세스가 하는 일과 동일하다면, 새로운 프로세스를 생성하거나 두 프로세스 사이에서 데이터 교환을 위한 IPC를 적용하기 보다 프로세스 안에 여러 스레드를 만들어 나가는 것이 더 효율적이다.

<br/> 

- 스레드도 일종의 작업 단위기 때문에 프로세스처럼 작업이 처리된다. 즉, 스레드도 프로세스처럼 작업을 병렬로 처리하여 속도를 높일 수 있다.

<br/> 

![thread](/assets/img/thread.png)

- 스레드는 일종의 함수로 구현되기 때문에 데이터(지역 변수)를 다루고, 데이터를 관리하기 위한 stack 메모리 영역을 가진다. 
    - 이 stack 공간은 프로세스가 가지는 stack 메모리 영역과는 별개이며, 스레드의 메모리 영역을 thread stack이라 부른다. 
    - 프로세스는 메모리 영역을 크게 4가지(code, data, stack, heap)으로 나눌 수 있지만, 스레드는 thread stack 메모리 공간만 가지게 된다. 
    - 스레드 안에 포함된 데이터는 thread stack에 저장된다. (프로세스의 stack 영역에는 스레드의 지역변수는 포함하지 않는다.)
    - 프로세스 내부의 Code, Data, Heap 영역과 자원들(File, I/O 등)을 같은 프로세스 내 스레드끼리 공유하면서 실행한다.
    - 각 스레드는 PC(Program Counter), SP(Stack Pointer), Registers, Stack 등을 고유하게 가진다.

> [ 스레드가 독립적인 스택을 가지는 이유 ]<br/> 
> 스택은 함수 호출시 전달되는 인자, 되돌아갈 주소값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간이다. 스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능하는 것이고, 이는 독립적인 실행 흐름(경로)가 추가되는 것이다. 따라서 스레드의 정의에 따라 독립적인 실행 흐름을 추가하기 위한 최소 조건으로 독립된 스택을 할당한다.
><br/> <br/> 
> [ 스레드가 독립적인 PC와 register를 가지는 이유 ]<br/> 
> PC(Program Counter)나 레지스터는 현재 명령어가 어디까지 수행되었는지, 수행될 때 쓰던 데이터는 무엇이었는지 알려준다. 스레드는 CPU를 할당받을때 프로세스처럼 스케쥴러에 의해 결정되므로 명령어가 연속적으로 실행됨을 보장하지 못한다. 어디까지 실행되었는지 기록할 필요가 있기 때문에 스레드가 각자의 PC를 가진다.

<br/> 

- 하나의 프로세스는 내부에 하나의 스레드 또는 여러개의 스레드를 가질 수 있다.
    - Single-threaded Process : 하나의 실행 경로를 가지는 프로세스이다.
      - 보안은 높지만 성능이 낮다.
      - 한 프로세스가 한 작업을 수행한다.
    - Multi-threaded Process : 여러 개의 실행경로를 가지는 프로세스이다.
      - 보안이 낮지만 성능이 높다.
      - 한 프로세스가 여러 작업을 수행한다.

- 한 스레드가 프로세스 자원을 변경하면 다른 이웃 스레드(sibling thread)도 변경 결과를 즉시 볼 수 있다.


<br/> 
<br/> 

## 스레드 장/단점

---


### 스레드 장점

1. 반응성 
    - 특정 스레드가 I/O 작업을 처리 중이거나(blocked) 긴 작업을 수행 중이여도 다른 스레드는 본인의 일을 계속 할 수 있다.
2. 자원 공유
    - 프로세스는 IPC를 이용해야지만 자원을 공유할 수 있지만, 스레드끼리는 프로세스의 자원을 서로 공유한다.
3. 경제적
    - 프로세스의 자원을 공유하기 때문에 새로운 메모리 주소 공간을 할당받을 필요가 없어 생성에 자원이 적게 들어간다.
    - 스레드간 문맥 교환할 때 캐시 메모리를 비우지 않아도 된다. 같은 메모리 주고 공간을 사용하여 오버헤드가 적기 때문이다.
      - Thread Pool 을 사용하여 오버해드를 해결할 수 있다.
4. 확장가능성


<br/> 

### 스레드 단점

- 공유 자원을 사용하기 때문에 동기화 문제를 고려해야 한다.
  - lock을 사용함으로써 공유자원에 대한 동기화를 해결할 수 있는데, lock이 과도하면 병목 현상이 발생하여 성능 저하를 유발할 수 있다.
  - 적절한 부분만 lock을 하는 것이 필요하다 (임계 영역 Critical Section Only)
    > 임계 영역 : 병렬 컴퓨팅에서 둘 이상의 스레드가 동시에 접근해서는 안되는 공유 자원(자료 구조 또는 장치)의 독점을 보장하는 코드 영역이다. 임계 구역은 지정된 시간이 지난 후 종료된다. 어떤 스레드가 임계 구역에 들어가고자 한다면 지정된 시간만큼 대기해야 한다. 스레드가 공유자원의 배타적인 사용을 보장받기 위해 임계 구역에 들어가거나 나올 때는 세마포어, 뮤텍스와 같은 동기화 매커니즘이 사용된다.


<br/> 
<br/> 


## 멀티 프로세싱 Multi-Processing

---

- 다수의 프로세서(Processor)가 다수의 프로세스를 동시에 처리하는 것이다.
    > 멀티 프로그래밍 : 다수의 프로세스를 메모리에 적재하여 프로세스를 번갈아가며 처리하는 것이다.<br/>
    > 멀티 태스킹 : 다수의 작업을 운영체제 스캐줄링에 의해 번갈아가며 처리하는 것이다.
- 프로세스(CPU)는 프로세스와는 다른 개념이다.
  - 각 프로세서는 다수의 프로세스를 처리하며, 각 프로세스는 다수의 프로세서에 의해 처리된다.
  - 각 프로세서가 자원을 공유하며 프로세스를 처리하기 때문에, 하나의 프로세서가 고장나도 작업(Job)은 정지되지 않는다.
  - 즉, 여러 프로세서가 작업을 병렬처리 하는 것이다.
- 멀티 프로세싱을 이용하는 경우 여러 개의 단일 프로세싱보다 비용이 절약된다.
  - 프로세서가 주변장치, 대용량 저장장치, 전원 공급장치를 서로 공유하기 때문이다.

<br/>

### 멀티 프로세싱 장점

- 한 프로세스가 죽더라도 다른 프로세스에는 영향을 미치지 않고 정상적으로 수행된다.

<br/>

### 멀티 프로세싱 단점

- 문맥 교환에서의 오버헤드가 발생한다.
  - 문맥 교환과정에서 캐시 메모리 초기화 등의 무거운 작업이 진행되고, 많은 시간이 소모되는 오버헤드가 발생한다.
  - 프로세스는 각각의 독립된 메모리 영역을 할당받았기 때문에 프로세스 사이에서 공유하는 메모리가 없어 문맥 교환 발생 시 캐시에 있는 모든 데이터를 리셋하고 다시 캐시 정보를 불러와야 한다.
- 멀티 스레드보다 많은 메모리 공간과 CPU 시간을 차지한다.
- 프로세스는 각각의 독립된 메모리 영역을 할당받았기 때문에 프로세스 간 공유를 하기위해서는 IPC를 사용해아한다.


<br/>

> 멀티 프로세스와 멀티 스레드의 차이점<br/>
> 멀티 프로세스: 독립적인 다수의 프로세스, 메모리 공간(코드, 데이터, 힙, 스택)을 공유하지 않는다.<br/>
> 멀티 스레드: 하나의 프로세스 내에 존재하는 다수의 스레드, 메모리 공간(코드, 데이터, 힙)을 공유하지만, 스택 영역은 공유하지 않는다.


<br/>

## 멀티 태스킹 Multi-tasking

---

- Task는 프로세스의 개념보다 확장된 개념이다.
    > Job : 어떠한 작업 실행에 필요한 모든 일이다. 실행 중인 일의 완전한 단위로 task의 집합체, 프로세스들의 유닛이다.<br/>
    > Task (What): 실행되는 일의 단위로 job의 일부분이다. 프로세스가 태스크를 실행한다고 볼 수 있다.<br/>
    > Process (Who): 실행 중인 프로그램이다. 연관된 task 또는 method가 모인 것이다.
- Task가 하나의 프로세서(CPU) 상에서 운영체제의 스케줄링 방식에 따라 조금씩 번갈아가며 수행되는 것이 멀티 테스킹의 개념이다.
- 빠른 속도로 조금씩 번갈아가며 Task를 처리하여 유저가 느끼기에는 마치 동시에 처리되는 것처럼 보인다.
- 멀티 태스킹의 스케줄링은 멀티 프로그래밍 방식(Multi-programming), 시분할 방식(Time-sharing), 실시간 시스템 방식(Real-time) 등이 있다.
- 멀티 태스킹은 비선점형(Non-preemptive), 선점형(Preemptive) 멀티 태스킹으로 나눌 수 있다.
  - 프로그램은 실행되면 프로세스가 되고, 프로세스는 여러 스레드를 실행시킨다.
  - 여러 프로그램에서 만들어지는 스레드는 CPU의 한정된 자원을 사용하기 위해 경쟁 중인 관계에 있다.
  - OS는 CPU의 시간을 나눠 여러 스레드들을 돌아가며 실행하게 하는데, 이 때 CPU를 차지하고 있는 스레드가 CPU 연산이 필요 없음을 나타냈을 경우에만 운영체제가 이를 회수할 수 있는 경우를 비선점형 멀티태스킹이라 한다.
  - 프로세스가 CPU를 차지하여 사용하더라도 OS가 개입하여 강제로 CPU 사용을 빼앗아올 수 있는 경우를 선점형 멀티태스킹이라 한다.

<br/>

## 멀티 스레딩 Multi-threading

---

- 하나의 프로세스를 다수의 스레드로 구성하여 서로 자원을 공유하여 효율적으로 사용해 작업 처리 속도를 향상시키는 것이다.
- 각 스레드는 프로세스 내에 존재하며 Code, Data, Heap 영역을 공유하며 데이터를 주고받기 때문에 IPC에 비해 통신 오버헤드가 적고 속도가 빠르다.
- 시스템의 처리량이 향상되고, 자원 소모가 줄어들어 프로그램의 응답시간이 단축된다.
- 2가지 유형의 스레드
  - Kernel thread : OS가 직접 관리하는 스레드이다.
  - User thread : 사용자가 생성, 관리하는 스레드이다. (Thread Library 사용)
  - OS는 kernel thread만 스케줄링 하므로 user thread가 실행되기 위해서는 kernel thread에 매핑되어야 한다.
  - 매핑 모델은 다대일, 일대일, 다대다 모델이 있다.

<br/>

### N : 1 다대일 모델

- 여러 user thread를 하나의 kernel thread에 매핑한다.
- 한 스레드 block은 프로세스 전체 block으로 이어진다.
  - 병행성이 낮다.
  - multi-core system에서 병렬 실행이 불가능하다.

![thread](/assets/img/multiThreading.png)

<br/>

### 1 : 1 일대일 모델

- 하나의 user thread를 하나의 kernel thread에 매핑한다.
- 다대일 보다 높은 병행성을 가진다.
- 병렬 실행이 가능하다.
- 커널 스레드 개수가 증가하여 성능 저하를 야기한다.
  - 시스템 내 스레드 개수를 제한한다.

![thread](/assets/img/multiThreading2.png)

<br/>

### N : N 다대다 모델

- n개의 user thread를 m(<= n)개의 kernel thread에 매핑한다.
- 다대일의 병행 실행과 일대일의 커널 스레드 개수 문제를 개선했다.

![thread](/assets/img/multiThreading1.png)

<br/>

### Two-level 모델

- 다대다에 일대일을 결합한 방식이다.

![thread](/assets/img/multiThreading3.png)

<br/>

### 멀티 스레딩 장점

- 시스템 <span style="color:#9fb584">**자원 소모가 감소**</span>한다. (자원의 효율성이 늘어난다)
  - 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있다.
  - 멀티 프로세스보다 작은 메모리 공간을 차지한다.
- 시스템 처리량이 증가하여 <span style="color:#9fb584">**처리 비용이 감소**</span>한다.
  - 스레드간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모가 줄어들게 된다.
  - 스레드 간 작업량이 작아 문맥 교환이 빠르다.
    - 스레드 간 문맥 교환은 캐시 메모리를 비울 필요가 없기 때문이다.
- 간단한 통신 방법으로 프로그램 <span style="color:#9fb584">**응답 시간을 단축**</span>한다.
  - 스레드는 프로세스 내 Stack 영역을 제외한 모든 메모리를 공유하기 때문에 통신 부담이 적다.
- 프로그램의 일부 스레드가 중단되거나 긴 작업을 수행해도 프로그램 수행이 계속되어 사용자에 대한 <span style="color:#9fb584">**응답성이 증가**</span>한다.
  - 하나의 스레드가 이미지 파일을 로드하는 동안 다른 스레드에서 사용자와 상호작용이 가능하다.
- 멀티프로세서를 활용한다.
  - 다중 CPU 구조에서는 각 스레드가 다른 프로세서에서 병렬로 수행될 수 있으므로 병렬성이 증가한다.


<br/>

### 멀티 스레딩 단점

- 동기화 문제가 발생한다.
  - 불필요한 부분까지 동기화하는 경우 과도한 lock으로 인해 병목현상을 발생시켜 성능이 저하될 가능성이 높다.
  - 동기화 방법에는 뮤텍스와 세마포어가 있다.
- 한 스레드에 문제가 발생하면 전체 프로세스가 영향을 받는다.

<br/>

## Thread Library

---

- 사용자에게 스레드 생성, 관리 API를 제공하는 library이다.
  - library 구현 방법: User-level library, Kernel-level library
- 비동기 스레딩, 동기 스레딩 2가지 threading 전략이 있다.

<br/>

### 비동기 스레딩

- 부모는 자식 생성 후 즉시 실행을 재개한다.
- 모든 스레드는 독립적으로 실행되며(데이터 공유가 거의 없다) 부모는 자식의 종료를 알 필요가 없다.
- multithreading server에서 사용되는 전략이다.

<br/>

### 동기 스레딩

- 부모는 모든 자식 종료 후 실행을 재개한다. (fork-join 전략)
  - 자식 스레드들은 서로 독립적으로 실행된다.
- 보통 데이터 공유가 많다.


<br/>
<br/>

## Implicit Threading

---

- 수백 수천 개의 thread를 가지는 multi-threaded application이 필요할 때마다 스레드를 생성하면 application의 성능이 저하(많은 스레드 생성 비용)되고, system resource가 고갈될 수 있다.
- 스레드의 생성과 관리를 어플리케이션에서 분리하여 compiler와 thread library가 수행하게 한다. 
  - Thread Pool
- 개발자는 병렬로 실행할 수 있는 작업만 식별하여 작업을 함수로 작성한다. 
- 이후 런타임 라이브러리를 통해 가용한 스레드에 매핑된다.

<br/>

### Thread Pool

---

- 프로세스에서 사용되고 있는 스레드의 개수를 관리한다.
- 프로세스 시작 전 적정 수의 스레드를 미리 생성하여 (Thread Pool) 관리한다.
  - 생성된 스레드들은 작업을 할당받기 위해 대기 상태에 있게 된다.
  - 작업 발생시 대기 중인 스레드 중 하나를 선택하여 작업한다.
  - 작업 완료 시 해당 스레드는 다시 대기 상태로 돌아가고, 새로운 작업을 할당받을 준비를 한다.
- 스레드 생성 및 삭제에 따른 오버헤드를 줄일 수 있다.
- 특정 시점에 동시에 처리할 수 있는 작업 개수를 제한할 수 있다.
- 어플리케이션의 성능 ⇧ 시스템 안전성 ⇧


<br/> 

###  Thread Pool 장점

- 자원 효율성
  - 미리 정해진 개수의 스레드를 생성하여 관리하기 때문에 스레드 생성, 삭제에 따른 오버헤드를 줄일 수 있다.
  - 시스템 자원을 효율적으로 관리할 수 있고, 불필요한 자원 소모를 방지한다.
- 응답성 및 처리량 향상
  - 작업을 대기 상태로 유지하여 작업 처리 속도를 향상시킨다.
  - 작업이 발생하면 대기 중인 스레드 중 하나를 선택하여 작업을 할당하기 때문에 병렬로 작업 처리를 할 수 있다.
- 작업 제어
  - 동시에 처리할 수 있는 작업 개수를 제한할 수 있다.
  - 스레드 풀의 크기를 조절하여 시스템 부하를 조절한다.
  - 과도한 작업 요청으로 인한 성능 저하를 방지할 수 있다.
- 스레드 관리
  - 스레드의 생명 주기를 관리할 수 있다.
  - 스레드 생성, 재사용, 종료 등을 관리하므로 스레드의 안전한 운영을 도와준다.


<br/> 

###  Thread Pool 크기 설정 요인 

1. CPU 코어의 개수
    - 서버가 많은 수의 코어를 가지고 있어도 애플리케이션이 일부 코어만 사용 가능한 경우 애플리케이션에서 사용 가능한 코어의 수가 스레드 풀의 크기를 결정한다.
2. 작업의 종류
    - CPU Bound Tasks
      - 코어 하나는 한 번에 하나의 스레드만 실행 할 수 있기 때문에 CPU를 점유하는 작업이 한 스레드에서 실행되고 있다면 다른 스레드는 그 시간 동안 아무것도 할 수 없다.
      - 스레드의 크기를 늘려도 메모리를 낭비할 뿐 성능 향상에는 도움이 되지 않는다.
      - CPU Bound 작업의 경우 CPU 코어 개수와 동일하게 스레드 풀의 크기를 정하는 것이 좋다.
    - I/O Bound Tasks
      - I/O 작업이 되는 동안 CPU는 기다리기만 할 뿐 자유롭다.
      - 즉, 스레드를 하나 더 이용할 경우 CPU free time 동안 다른 작업을 수행할 수 있다.
      - I/O Bound 작업의 경우 코어 개수 뿐만 아니라 대기 시간을 고려하여 스레드 풀의 크기를 결정해야 한다.
    > CPU-bound Process : 해당 프로세스에서 CPU 작업(계산)이 차지하는 비중이 높은 프로세스<br/>
    > I/O bound Process : 해당 프로세스에서 I/O 작업(입출력)이 차지하는 비중이 높은 프로세스

<br/>

- 적정 스레드 개수 = 사용 가능한 코어 개수 * ( 1 + 대기시간 / 서비스 시간)
  - 대기 시간 : I/O Bound 작업, 스레드가 WAITING, TIMED_WAITED 상태로 대기 중인 시간
  - 서비스 시간 : 대기 시간을 제외한 실제로 작업이 동작 중인 시간
  - CPU Bound 작업의 경우 대기시간이 0에 가깝기 때문에 적정 스레드 개수가 사용 가능한 코어 개수에 수렴한다.
  - I/O Bound 작업의 경우 대기시간이 길 경우 스레드 풀의 크기를 키워야하고, 대기시간이 짧다면 스레드 풀의 크기를 줄여야한다.
- 여러 개의 스레드 풀이 존재할 경우 CPU 목표 사용률을 공식에 추가해 줄 수 있다.
  - 적정 스레드 개수 = 사용 가능한 코어 개수 * 목표 CPU 사용률 * ( 1 + 대기시간 / 서비스 시간)

<br/> 
<br/> 

[^footnote]: The footnote source
[^fn-nth-2]: The 2nd footnote source
