---
title: "2-3 Tree"
author: gyeomji
date: 2024-05-06 10:00:00 +0900
categories: [Data Structure]
tags: [Data Structure, 2-3 Tree]
pin: false
math: true
mermaid: true
---

<br/> 
트리의 높이가 균형을 이루며 <span style='background-color:#c8d8b4'>내부 노드의 차수가 2 또는 3인 균형 탐색 트리</span>로, 루트로부터 각 이파리노드까지 경로의 길이가 같고, <span style="color:#9fb584">**모든 이파리 노드들이 동일한 층에 있는 완전한 균형트리**</span>이다. 2-3트리가 2-노드들만으로 구성되면 Full Binary Search Tree와 동일한 형태를 가진다.

<br/> 

>💡  <span style="font-size: 15px">2-노드 : 차수가 2인 노드로 1개의 키를 가진다.<br/>
> 　 　3-노드 : 차수가 3인 노드로 2개의 키를 가진다.

<br/> 

## 2-3 트리 특징

---

1. <span style="color:#9fb584">**이파리 노드들이 동일한 층**</span>에 있어야 하므로 트리가 위로 자라나거나 낮아진다.
    - k1키를 가진 2-노드는 2개의 서브트리를 가지는데, 노드의 왼쪽 서브트리에는 k1보다 작은 키들이 있고, 오른쪽 서브트리에는 k1보다 큰 키들이 있다.
    - k1, k2 키를 가진 3-노드는 3개의 서브트리를 가지는데, 왼쪽 서브트리에는 k1보다 작은, 중간 서브트리에는 k1보다 크고, k2 보다 작은, 오른쪽 서브트리에는 k2보다 큰 키들이 있다.

![2-3Tree](/assets/img/2-3Tree.png){: width="350" height="300"}


2. <span style="color:#9fb584">**중위 순회를 수행하면 키들이 정렬된 결과**</span>를 얻는다.
    - 2-3트리에서도 이진탐색트리와 유사한 방법으로 중위 순회를 수행한다.
    - 2-노드는 이진탐색트리의 중위 순회 방문과 동일하다.
    - 3-노드는 노드의 왼쪽 서브트리에 있는 모든 노드들을 방문한 후 k1을 방문한다.
    - 이후 중간 서브트리에 있는 모든 노드들을 방문한다.
    - 다음으로 k2를 방문하고, 마지막으로 오른쪽 서브트리에 있는 모든 노드들을 방문한다.

<br/>

## 2-3 트리 시간복잡도

---

- 탐색, 삽입, 삭제 연산 시간은 각각 <span style="color:#9fb584">**트리 높이에 비례**</span>한다.
  - 각 연산은 루트 노드 -> 이파리노드까지 탐색해야하고, 삽입이나 삭제는 분리나 통합 연산을 수행하며 다시 루트노드까지 올라가는 경우도 있기 때문이다.
  - 단, 개별적인 <span style="color:#9fb584">**분리 연산이나 통합 연산**</span>은 각각 트리의 지역적인 부분에서만 수행되므로 <span style="color:#9fb584">**O(1)**</span> 시간이 소요된다.
- 2-3 트리가 가장 높은 경우는 모든 노드가 2-노드인 경우이고, 이 때 트리의 높이는 log2(N+1)이다.
- 트리의 모든 노드가 3-노드이면 트리의 높이가 최소이며, 높이는 log3N ~ 0.63log2N이다.
- 따라서 <span style="color:#9fb584">**2-3 트리의 탐색, 삽입, 삭제 연산의 수행시간은 각각 O(logN)**</span>이다.


<br/>

## 2-3 트리 탐색 연산

---

: 루트 노드에서 시작하여 방문한 노드의 키들과 탐색 키를 비교하며 다음 레벨의 노드를 탐색한다.

<br/>

![2-3Search](/assets/img/2-3Search.png)

<br/>

## 2-3 트리 삽입 연산

---
  
: 삽입 수행 전 먼저 탐색과 동일한 과정을 거쳐 새로운 키가 삽입될 이파리 노드를 찾아야 한다.

### 분리 연산

![2-3Append](/assets/img/2-3Append.png)

- overflow가 발생된 노드에 3개의 키가 있을 때, k1 < k2 < k3 라면
- k1과 k3을 각각 2-노드에(하나는 기존 노드, 다른 하나는 생성하여) 저장하고, 중간값인 k2를 부모노드로 올려 k1과 k3의 분기점 역할을 하도록 한다.

<br/>

### Leaf Node에서의 삽입 방식

1. 이파리 노드가 2-노드이면 그 노드에 새 키 삽입
2. 이파리 노드가 3-노드이면 새로운 키를 저장할 수 없으므로 (overflow)  => `분리 Split 연산 `
   1. 해당 노드에 있는 기존의 2개 키와 새로운 키 중 중간값이 되는 키를 부모 노드로 올린다.
   2. 남은 2개의 키를 각각 별도의 노드에 저장
   3. 부모 노드가 2-노드이면, 부모 노드에 저장하고 삽입 연산을 종료한다.
   4. 부모 노드가 3-노드이면 분리 연산을 부모 노드에서도 수행한다.
        - 이 과정은 루트까지 올라가면서 반복될 수 있다.
        - 루트에서 노드 분리가 일어나면 <span style="color:#9fb584">**2-3트리의 높이가 1 증가**</span>한다.

<br/>

![2-3Append2](/assets/img/2-3Append2.png)

<br/>


## 2-3 트리 삭제 연산

---

: 이동(Transfer) 연산과 통합(Fusion) 연산을 사용한다.


- 삭제는 <span style="color:#9fb584">**항상 이파리노드**</span>에서 이루어진다.
- 삭제할 키가 있는 노드가 이파리 노드가 아닌 경우, 이진탐색트리의 삭제와 유사하게 <span style="color:#9fb584">**중위 선행자 또는 중위 후속자와 교환한 후에 이파리노드에서 실질적인 삭제를 수행**</span>한다.

>💡  <span style="font-size: 15px">중위 선행자 : 현 원소의 앞 원소 <br/> 　 　중위 후속자 : 현 원소의 뒤 원소</span>

<br/>

1. 삭제할 키 k가 있는 노드 n을 탐색한다.
2. <span style="color:#9fb584">**n이 이파리 노드일 경우**</span> k를 n에서 삭제한다.
    - <span style="color:#9fb584">**n != empty**</span> 
      - 알고리즘 종료
    - <span style="color:#9fb584">**n == empty**</span> 
      - n의 형제 노드들 중에 <span style="color:#9fb584">**3-노드가 있으면 이동 연산**</span> 수행
      - 형제 노드들 중 <span style="color:#9fb584">**3-노드가 없을 경우 통합 연산**</span> 수행
3. <span style="color:#9fb584">**n이 이파리 노드가 아닐 경우**</span> k의 중위 선행자가 있는 노드 y와 중위 후속자가 있는 노드 z탐색
    - y 또는 z에서 <span style="color:#9fb584">**이동 연산이 가능할 경우**</span>
      - 이동 연산 가능한 키를 k와 서로 교환하고 <span style="color:#9fb584">**이동 연산을 수행**</span>하며, k를 삭제한 후 알고리즘 종료
    - y 또는 z 둘다 <span style="color:#9fb584">**이동 연산이 불가능할 경우**</span>
      - y나 z 중 임의로 하나를 선택한다.
      - 선택된 노드의 키를 k와 서로 교환한 후 k를 삭제하고 <span style="color:#9fb584">**통합 연산을 수행**</span>한다.
   
> <span style="font-size: 15px">통합 연산 수행 후 루트 방향으로 연속적인 통합 연산이 수행될 수 있다.</span>

<br/>

### 이동 연산 Transfer

: 키가 삭제되어 empty 노드가 되었을 때, 해당 노드의 형제, 부모 노드의 도움을 받아 1개의 키를 empty노드로 이동 시키는 연산이다.

- 형제 노드는 반드시 3-노드여야 한다.
- 3-노드가 empty노드의 <span style="color:#9fb584">**왼쪽 형제노드**</span>라면, 2개의 키 중 <span style="color:#9fb584">**큰 키를 부모노드로**</span> 올려보내고 부모노드의 키를 empty노드로 내려 보낸다.
- 3-노드가 empty노드의 <span style="color:#9fb584">**오른쪽 형제노드**</span>라면, 2개의 키 중 <span style="color:#9fb584">**작은 키를 부모노드로**</span> 올려보내고 부모노드의 키를 empty노드로 내려 보낸다.
<br/>

![Transfer](/assets/img/transfer1.png)
![Transfer](/assets/img/transfer2.png)

<br/>

### 통합 연산 Fusion

: 노드가 empty일때 <span style="color:#9fb584">**이동 연산이 불가능한 경우**</span> 사용한다. 통합 연산과 분리 연산은 상호 역(Reverse) 연산 관계이다.

1. empty노드와 그의 형제노드를 1개의 노드로 통합한다.
2. empty노드와 그의 형제노드의 분기점 역할을 하던 부모노드의 키를 통합된 노드로 끌어내려 저장한다.

![fusion](/assets/img/fusion1.png)
![fusion](/assets/img/fusion2.png)

<br/>

## 2-3-4 트리

---

: 2-3 트리를 확장한 2-3-4 트리는 노드가 자식 노드를 4개까지 가질수 있는 완전 균형 트리이다.

- 2-3 트리보다 높이가 낮아 더 빠른 탐색, 삽입, 삭제 연산 수행이 가능하다.
- 2-3-4 트리는 삽입 연산을 루트 -> 이파리 노드로 내려가며 4-노드를 만날 때마다 미리 분리 연산을 수행할 수 있기 때문에 다시 이파리노드에서 위로 올라가며 분리 연산을 수행할 필요가 없고, 따라서 보다 효율적인 삽입 연산이 가능하다.
- 삭제 연산도 삽입과 유사하게 루트 -> 이파리 노드로 내려가며 2-노드를 만날 때마다 미리 통합 연산을 수행하므로 키 삭제 후 다시 루트로 올라가며 통합 연산을 수행할 필요가 없다.
- 하지만, 이런 삽입과 삽제 연산도 이론적으로는 2-3 트리의 수행시간과 동일한 O(log2N)을 가진다.

<br/>

[^footnote]: The footnote source
[^fn-nth-2]: The 2nd footnote source
