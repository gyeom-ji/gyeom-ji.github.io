---
title: "iOS 면접 준비 - 컴퓨터 구조"
author: gyeomji
date: 2024-08-05 10:00:00 +0900
categories: [Interview]
tags: [컴퓨터 구조]
pin: false
math: true
mermaid: true
---

<br/> 

## ✏️ 컴퓨터 구조와 관련하여 CPU, RAM, 저장장치의 역할과 상호 작용

---

### 중앙처리장치 CPU (Central Processing Unit)

- 컴퓨터 시스템 전체를 제어하는 장치로서 입력장치에서 데이터를 입력 받아 처리한 후 출력장치와 기억장치로 데이터를 보낸다.
  - 프로그램 실행과 데이터 처리 기능을 수행한다.
- 제어장치, 연산장치, 레지스터 등으로 구성된다.
- 다양한 마이크로프로세서를 사용한다.

#### 상호작용

- CPU는 시스템 버스를 통해 RAM과 저장장치와 연결된다. 
- RAM에 저장된 프로그램에서 명령을 하나씩 제어장치로 꺼내 해독한다.
- 제어장치는 해독된 결과로 제어신호를 만들어 각 장치로 전달하여 동작되도록 한다.
- 필요시 결과를 저장장치에 저장한다.

![cpu](/assets/img/cpu.png "CPU 내부 구조")

<br/>

### RAM (Random Access Memory)

- CPU가 읽기, 쓰기를 하기 위한 기억장치로 명령어와 데이터를 저장한다.
- 휘발성 기억장치로 일정한 시간이 지나거나 전원 공급이 중단되면 기억장치 내 모든 데이터가 지워진다.
- 모든 위치에서 동일한 속도로 접근할 수 있다.

#### 상호작용

- RAM은 실행할 프로그램과 데이터를 저장한다.
- RAM은 프로그램 실행 중 필요한 데이터를 빠르게 제공하여 CPU의 성능을 최적화한다.

<br/>

### 저장장치 (Storage)

- 반영구적으로 데이터를 저장하고 보존할 수 있다.
- 보조기억장치에 저장된 데이터는 중앙처리장치와 직접 정보를 교환할 수 없기 때문에 주기억장치로 옮겨진 후 처리된다.
- 주기억장치에 비해 가격이 저렴하고 저장 용량이 크지만 속도가 느리다는 단점이 있다.
- 주요 형태는 HDD(하드 디스크 드라이브)와 SSD(솔리드 스테이트 드라이브)가 있다.
- HDD: 회전하는 디스크에 데이터를 저장하는 방식으로, 비교적 저렴하지만 속도가 느리다.
- SSD: 플래시 메모리를 사용하여 데이터를 저장하며, 빠른 속도와 내구성을 제공한다.

#### 상호작용

- CPU와 RAM의 데이터를 영구적으로 저장하거나 필요할 때 불러오는 역할을 힌다. 
- 운영체제, 애플리케이션, 사용자 데이터 등이 저장된다.


[📝 하드웨어](https://gyeom-ji.github.io/posts/computerArchitecture/)

<br/>

## ✏️ 캐시 메모리의 개념과 종류, 역할

---

- CPU의 처리 속도와 주기억 장치의 접근 속도 차이를 줄이기 위해 사용한다.
- RAM보다 빠른 고속 RAM으로 CPU에 자주 쓰이는 명령어와 데이터를 저장하여 처리 성능을 높인다.
- 캐시 메모리는 메모리 계층 구조에서 가장 빠른 소자이며, 처리속도가 거의 CPU의 속도와 비슷하다.
- 메인 메모리에서 자주 사용하는 프로그램과 데이터를 저장해둬 속도를 빠르게 한다.
  - CPU가 어떤 데이터를 원하는지 예측할 수 있어야 한다.
  - 작은 용량의 캐시 메모리가 CPU가 이후에 참조할 정보를 어느 정도 가진지에 따라 캐시의 성능이 결정되기 때문이다.
  - 이를 위해 캐시의 지역성(Locality)을 이용한다.
- 지역성을 활용하여 메인 메모리에 있는 데이터를 캐시 메모리에 불러와 두고, 프로세서가 필요한 데이터를 캐시 메모리에서 먼저 찾도록 하여 시스템 성능을 향상할 수 있다.
  - 주 기억장치를 접근하는 횟수가 줄어들어 처리속도가 향상된다.
- 캐시의 전반적인 성능은 일반적으로 캐시 메모리의 논리적 구성에 영향을 많이 받는다.

[📝 캐시메모리](https://gyeom-ji.github.io/posts/cacheMemory/)

<br/>

## ✏️ CPU 아키텍처의 종류(예: ARM, x86)와 특징

---


### x86

- 인텔이 개발한 32bit CPU이다.
  - x86프로세서는 인텔의 CPU와 호환되는 프로세서들이 사용하는 ISA를 부르는 말이다.
- CISC(복잡 명령어 집합 컴퓨터) 구조를 바탕으로 설계했지만, 현재는 내부적으로 RISC의 설계도 이뤄지는 하이브리드 아키텍쳐이다.
  - 복잡하고 다양한 명령어를 지원하여 프로그래밍의 유연성을 높인다.
- 주로 데스크탑, 노트북, 서버, 워크스테이션에서 사용하는 CPU 아키텍처이다.
  - Windows, Linux, Mac OS (BigSur 까지)
- 이전 버전과 호환성이 좋다.
- 설계가 복잡하고 전력 소모가 많다.
  - 이전 버전들과 호환하기 위해 구조를 추가하며 개발했기 때문에 복잡한 명령어 체계를 가진다.
  - CPU가 출시된 이후부터 현재까지 출시되는 CPU, ISA들이 모두 담겨져 있다.
- 명령어 길이가 서로 다르기 때문에 다른 명령어의 길이를 줄임으로 코드를 간결하게 해 디버깅 속도를 높일 수 있다.


<br/>

### x86_64 (amd64)

- 인텔기반 64bit CPU이며 x86과 호환된다.

<br/>

### ARM

- arm 기반 32bit CPU이다.
- x86과 호환되지 않는다.
  > x86에서 빌드한 라이브러리 arm에서 실행 불가 (호환 x)<br/>
  > x86에서 빌드한 라이브러리 x86_64에서 실행 가능 (하위 호환)<br/>
  > 라이브러리를 사용하고자 할 때, 실행할 서버의 아키텍처를 확인하고, 그에 맞는 라이브러리를 사용해야 한다.
- 단순 명령어 집합 컴퓨터(RISC) 구조로 모바일, 임베디드 시스템에서 주로 사용된다.
  - Linux, Mac OS (Monterey 부터), Android, iOS, 기타 모든 작은 기기에서 성능을 내야하는 경우(공유기도 해당)
  - 간단하고 효율적인 명령어를 사용하기 때문에 구조가 간단하여 성능과 에너지 효율성을 최적화한다.
- 최근 고성능 ARM 프로세서가 개발되어 데스크탑과 서버에서도 사용된다.
  - 애플 M1칩을 기점으로 노트북, 데스트톱 등 PC에서 사용된다.
  - M1칩은 기존 인텔 기반 맥북보다 빠르고 저전력 모드에서도 높은 성능을 발휘한다.
  - ARM 아키텍처가 가지고 있는 에너지 효율성의 장점을 살린것이다.
    > M1 Mac은 x64, x86_64로 빌드된 프로그램 실행이 가능하다.<br/>
    > ARM 머신 내부에 x86 가상환경을 만들고 그 안에서 실행하는 `Rosseta` 에물레이터가 있기 때문이다. 
- 저전력 소모로 배터리 수명을 연장한다.
  - 메모리 저장방식을 2가지 선택하여 사용하기 때문에 메모리 사용 유연성을 높인다.
- 명령어 길이가 정해져 있어 많은 코드를 구현해야한다.
  - PC에서 구현하기 위해서는 ARM을 지원하는 프로그램으로 실행해야 하기 때문에 속도가 느리다.


<br/>

### arm64 (arm64/v8)

- arm 기반의 64bit CPU이다.
- 32bit arm과 호환된다.

<br/>

[📝 컴퓨터 아키텍처](https://gyeom-ji.github.io/posts/microArchitecture/)

<details>
<summary>명령어 집합 구조 ISA, CISC, RISC 💡</summary>
<div markdown="1">

### 명령어 집합 구조 ISA (Instruction Set Architecture)

---

- CPU가 이해하고 실행할 수 있는 명령어 집합이다.
- CPU마다 ISA가 다를 수 있다.
- 이 명령어 집합들은 OS와 어플리케이션에 사용된다.
- ISA의 종류는 x86, AMD64(x86-64), ARM, MIPS, AVR 등이 있다.
  - 컴퓨터 마다 필요한 연산 능력과 컴퓨팅 환경이 다르기 때문에 다양한 ISA가 개발되고, 사용된다.
- CPU가 이해하는 명령어가 달라지면 제어장치가 명령어를 해석하는 방식, 사용되는 레지스터의 종류와 개수, 메모리 관리 방법 등 많은 것이 달라진다.
  - 이는 CPU 하드웨어 설계에도 큰 영향을 미친다.
- ISA는 CPU의 언어임과 동시에 CPU를 비롯한 하드웨어가 소프트웨어를 어떻게 이해할지에 대한 약속이라 볼 수 있다.

> ISA가 다르다는 건 CPU가 이해할 수 있는 명령어가 다르다는 뜻이다. 같은 소스 코드로 만들어진 프로그램이라 할지라도 ISA가 다르면 CPU가 이해할 수 있는 명령어, 어셈블리어가 달라진다. ISA가 같은 CPU들은 서로 명령어를 이해할 수 있지만 ISA가 다르면 서로의 명령어를 이해할 수 없다. (ISA는 일종의 CPU언어라고 볼 수 있다) 인텔 계열 프로세서와 AMD 계열 프로세서는 내부 구조가 다르지만 같은 언어, 즉 같은 ISA(x86)을 사용하기 때문에 문제 없이 프로그램이 작동된다. ISA가 다른 프로세서일 경우 x86 ISA로 만들어진 프로그램은 바로 작동할 수 없다.

<br/>

#### CISC (Complex Instruction Set Computer)

- 복잡한 구성의 명령어 셋팅을 가지는 CPU 아키텍처이다.
- 폰 노이만 구조로 구성된다.
- 가변 길이 명령어 형식이다.
- 다양한 주소 지정 모드가 있다.
- 명령어가 복잡하기 때문에 명령어를 해석하는데 시간이 오래 걸리며 명령어 해석에 필요한 회로가 복잡하다.
- 마이크로 프로그래밍(S/W) 제어 방식이다.
  - 명령어가 소프트웨어적이므로 호환성이 높다.
- 명령어 파이프라이닝이 불리하다.
  - 명령어의 크기와 실행되기까지 시간이 일정하지 않다.
  - 명령어 하나를 실행하는데 여러 클럭 주기가 필요하다.
  - 대다수의 복잡한 명령어는 사용 빈도가 낮다.
- 메모리에서 오퍼랜드(피연산자)를 조작하는 명령어들이 많다.
- 컴파일 과정이 쉽고 호환성이 좋지만 속도가 느리다.
- 개인용 PC와 같이 고사양 작업을 필요로 하는 곳에 사용된다.
- CISC 명령어 집합을 가진 CPU 아키텍처 : AMD64, x86

<br/>

#### RISC (Reduced Instruction Set Computer) 

- 간단한 구성의 명령어 셋팅을 가지는 CPU 아키텍처이다.
  - CISC의 많은 명령어와 주소 모드 중 실제로 사용되는 명령어는 몇 개 되지 않는다는 사실을 바탕으로 적은 수의 명령어만으로 명령어 집합을 구성했다.
  - CPU 명령어 개수를 줄여 명령어 해석시간을 줄임으로써 개별 명령어의 실행 속도를 빠르게 한다.
- 하버드(Harvard)에서 개발한 아키텍처로 하버드 구조를 사용한다.
- 단순하고 적은 수의 고정 길이 명령어와 주소 지정 모드를 사용한다.
  - 명령어의 개수가 적어 처리 속도가 빠르다.
  - 명령어 길이가 고정되어 있으므로 해석 속도가 빠르다.
- 논리회로를 이용한 하드웨어적 제어 방식이다.
  - 명령어가 하드웨어적이므로 호환성이 낮다.
- 명령어 파이프라이닝에 유리하다.
  - 한 클럭 사이클에 하나의 명령어를 실행하기 때문에 파이프라인을 기다리게 하지 않는다.
- Load-Store 구조이다.
  - 데이터 처리를 레지스터 기준으로 수행한다.
  - 연산을 수행하기 위해 메모리에 직접 접근하는 명령어를 제한하고 대신 레지스터를 활용한다.
  - 메모리 접근은 store, load 명령어로 제한하여 불필요한 메모리 접근을 줄인다.
    - 메모리에 연산할 것이 있을 경우 load 명령어로 레지스터에게 전달
    - 레지스터에서 연산이 끝나면 store 명령으로 다시 메모리에 결과를 가져와 저장
- 모든 오퍼랜드(피연산자)는 CPU내 레지스터에서 조작된다.
- 스마트폰 또는 임베디드 기기와 같이 전력 소모가 적고 처리 속도가 빨라야 하는 곳에 사용된다.
- RISC 명령어 집합을 가진 CPU 아키텍처 : ARM, RISC-V

> 파이프 라이닝 : 인출과 실행 단계가 겹치도록 프로세서를 설계하여 명령어 여러 개가 다양한 단계에 걸쳐 진행되도록 만든다. 명령어 한 개가 완료되는 데는 같은 시간이 걸리지만, 여러 명령어를 동시에 처리하므로 전체적인 처리 속도가 빨라진다.

</div>
</details>

<br/>

## ✏️ iOS 기기에서 사용되는 AP(Application Processor)의 특징과 역할

---

### Application Processor (AP)


- AP는 모바일 기기의 주요 하드웨어 구성 요소 중 하나로 CPU, GPU, 캐시 메모리, 이미지 신호 처리 장치(ISP), 신호 처리 장치(DSP)등을 포함한다.
- iOS 기기에서 사용되는 AP는 주로 ARM 아키텍처를 기반으로 하며, 고성능 및 저전력을 제공한다.
- 스마트폰, 태블릿 등에서 운영체제와 애플리케이션을 실행하는 중앙 처리 장치이다.
  - 시스템 온 칩(SoC) 형태로 여러 기능을 통합한다.
- 사용자 인터페이스, 웹 브라우징, 멀티 미디어 재생, 게임 실행 등 다양한 애플리케이션을 처리하고 실행하는데 특화된 프로세서이다.
- 여러 코어와 높은 클럭 속도로 멀티태스킹 성능을 향상시킨다.
  - ex) Apple의 A 시리즈 칩
- 전력 소모를 최소화하여 모바일 기기의 배터리 수명을 연장한다.
- CPU, GPU, 메모리 컨트롤러, 이미지 프로세서 등을 한 칩에 통합하여 공간 효율성을 높이고 성능을 최적화합니다.
  - 이러한 통합 구성으로 인해 고성능 계산과 그래픽 처리 멀티미디어 기능 등을 제공할 수 있다.
- 생체 인식(얼굴 인식, 지문 인식), 데이터 암호화 등의 보안 기능을 제공한다.
  - ex) Secure Enclave
- AI 및 머신 러닝 작업을 가속화하는 뉴럴 엔진, 이미지 및 비디오 처리에 특화된 ISP(이미지 신호 프로세서) 등을 포함한다.
- 매년 새로운 기술과 개선된 아키텍처를 도입하여 성능과 효율성을 지속적으로 향상시킨다.
- 이러한 특징들이 결합되어 iOS 기기에서 높은 성능과 효율성을 제공한다.

<br/>

<details>
<summary>AP 구성 요소와 작동 원리 💡</summary>
<div markdown="1">

#### 구성 요소

1. 중앙 처리 장치 CPU
  - 애플리케이션 실행을 담당한다.
  - 명령어를 해석하고 처리하여 데이터를 처리하고 연산을 수행한다.
2. 그래픽 처리 장치 GPU
  - 그래픽 연산을 처리하고 화면 출력을 담당한다.
  - 게임, 영상 재생 등 그래픽 집약적인 작업을 빠르고 부드럽게 처리할 수 있다.
3. 메모리 컨트롤러
  - 시스템 메모리(RAM)와 데이터 통신을 관리한다.
  - 애플리케이션에 필요한 데이터를 메모리에 읽고 쓰는 역할을 수행한다.
4. 디지털 신호 처리 프로세서 DSP
  - 음성, 영상, 오디오 신호 처리 등 디지털 신호 처리 작업을 담당한다.
  - 음성 인식, 음성 통화 등과 같은 음성 관련 기능을 지원한다.
5. 네트워크 인터페이스
  - 모바일 기기의 네트워크 연결을 관리한다.
  - Wi-Fi, LTE, 5G 등 네트워크 기술을 지원하여 데이터 통신과 인터넷 연결을 제공한다.
6. 영상 및 멀티미디어 엔진
  - 동영상 재생, 이미지 처리, 사운드 출력 등 멀티미디어 기능을 처리한다.
  - 고화질 동영상 재생과 사운드 효과를 제공하는 등 다양한 멀티미디어 작업을 수행할 수 있다.
7. 센서 인터페이스
  - 모바일 기기에 내장된 센서(가속도계, 자이로스코프, 근접 센서 등)와의 상호작용을 관리한다.
  - 센서 데이터를 읽고 처리하여 애플리케이션에 제공할 수 있다.
8. 전력 관리 유닛
  - 모바일 기기의 전력 소비를 관리하고 효율적인 전력 사용을 도와준다.
  - 배터리 수명을 연장하고 전력 소모를 최적화하여 모바일 기기 사용 시간을 향상시킨다.

<br/>

#### 작동 원리

1. 애플리케이션 실행
  - 사용자가 모바일 기기에서 특정 애플리케이션을 실행하면 OS는 해당 애플리케이션을 AP에 할당한다.
  - AP는 CPU를 통해 애플리케이션의 명령어를 해석하고 처리하여 실행한다.
2. 멀티태스킹
  - AP는 멀티태스킹을 지원하여 여러 애플리케이션 간에 자원을 적절하게 분배하고 필요한 작업을 우선순위에 따라 처리한다.
3. 그래픽 처리
  - GPU가 내장되어 있어 고해상도의 그래픽 처리를 수행할 수 있다.
  - 게임 실행, 동영상 재생, UI 애니메이션 등 다양한 그래픽 작업을 빠르고 부드럽게 처리하여 모바일 기기 화면에 표시한다.
4. 메모리 관리
  - 메모리 컨트롤러를 통해 RAM과의 데이터 통신을 관리한다.
  - 애플리케이션은 필요한 데이터를 메모리에 읽고 쓰는 작업을 수행하는데 AP가 이를 효율적으로 관리하여 애플리케이션의 실행에 필요한 메모리를 적절히 할당하고 관리한다.
5. 전력 관리
  - AP에는 전력 관리 유닛이 내장되어 있어 전력 소비를 최적화하고 배터리 수명을 연장할 수 있도록 도와준다.
  - 애플리케이션이 필요하지 않은 경우 일시적으로 처리 속도를 낮추거나 비활성화하여 전력 소모를 줄일 수 있다.
6. 네트워크 연결
  - 네트워크 인터페이스를 통해 Wi-Fi, LTE, 5G 등 네트워크 기술을 지원해 모바일 기기의 네트워크 연결을 관리한다.


</div>
</details>


## ✏️ iOS에서 이미지 파일 포맷(PNG, JPEG 등)과 각 포맷의 특징

---

### PNG (Portable Network Graphics)

- 래스터 이미지 파일의 일종이다.
- 투명 또는 반투명 배경의 그래픽을 처리할 수 있다. 
- 이 파일 포맷은 특허가 없으므로 라이선스 없이도 이미지 편집 소프트웨어를 사용하여 파일을 열 수 있다.
- PNG 파일은 수백 개가 아닌 수백만 개의 색상 옵션을 처리하므로 GIF보다 훨씬 더 디테일한 이미지를 저장할 수 있다.
- PNG 이미지는 압축해도 데이터가 손실되지 않으며, 저장과 전송이 매우 간단하다.
  - 압축 과정에서 일부 정보가 사라지는 손실 압축 포맷(예: JPEG 파일)과 비교할 때 큰 장점이 될 수 있다.
- PNG 파일은 압축 시 모든 원본 데이터를 유지하므로 GIF 또는 JPEG보다 파일 크기가 훨씬 크다.
  - 컴퓨터의 하드 드라이브에서 공간을 많이 차지한다.
- PNG는 처음부터 웹을 염두에 두고 설계되었기 때문에 CMYK(Cyan, Magenta, Yellow, Black) 색상 모드를 지원하지 않는다.
  - 인쇄용으로 전송하기가 어려울 수 있다.
- 압축된 PNG에는 고품질의 디테일한 이미지 데이터가 포함되어 있지만, 파일 크기가 클수록 페이지 로드 시간과 응답 속도가 느려진다.

<br/>

### JPEG (Joint Photographic Experts Group)

- 디지털 사진을 저장하는 가장 일반적인 형식이다.
  - 대부분의 브라우저, 소프트웨어, 앱과 호환되는 가장 보편적인 이미지 파일 포맷이다.
- JPEG는 압축을 통해 이미지 파일 크기를 줄여서 저장하고, 웹 페이지에 쉽게 업로드할 수 있게 한다.
  - GIF와 같은 무손실 포맷에 비해 파일 크기가 훨씬 작다.
- JPEG 이미지는 최대 1,680만 개의 색상을 담아낼 수 있다.
  - 사람의 눈으로 볼 수 없는 모든 색상을 제거하여 파일 크기를 최대한 작게 유지한다.
- 압축률이 매우 높은 이미지를 처리할 때 품질이 저하된다.
- 너무 많은 데이터가 손실되면 색상 간 전환이 부드럽지 않아 이미지가 부자연스럽게 보이는 `포스터화` 현상이 발생할 수 있다.
- 이미지 품질에 심각한 영향을 줄 수 있는 결함(가장자리의 앨리어싱, 블루밍, 노이즈)이 나타날 수 있다. 
- `.jpg`, `.jpeg`, `.jpe`, `.jif`, `.jfif`, `.jfi` 확장자는 모두 JPEG 이미지이다.

<br/>

### HEIC, HEIF (High Efficiency Image Format)

- MPEG에서 개발된 이미지 포멧으로, 히프 또는 헤익이라 발음한다.
- 이미지 하나의 프레임이 아닌 이미지 컨테이너를 의미한다.
- 아이폰에서 동영상을 찍으면 H264 또는 HEVC 포멧으로 저장되는데 이 때 HEVC안에 스틸 이미지 하나가 HEIF 형태이다.
- iOS 11과 macOS High Sierra에서 처음으로 사진, 동영상 저장 포맷으로 정식 채택되었다.
- 기존 jpg는 8bit (RGB)까지 색정보를 담지만 HEVC는 12bit까지 가능하다.
- HEIF는 압축률이 높아 용량이 JPG보다 작다.
- 압축 때문에 처리속도가 JPG보다 엄청나게 느려서 대량 작업 시 불편하다.

<br/>

### ✏️ PNG와 JPEG의 차이점

- 압축 프로세스가 다르다.
  - PNG는 무손실 압축, JPEG은 손실 압축
- JPEG는 포함하는 데이터 양이 PNG보다 적어 파일 크기가 작다.
- PNG는 투명 배경을 지원하기 때문에 그래픽 디자인에 더 적합히다.

<br/>
<br/>


[^footnote]: The footnote source
[^fn-nth-2]: The 2nd footnote source