---
title: "가상 메모리"
author: gyeomji
date: 2024-05-14 10:00:00 +0900
categories: [Operating System]
tags: [Virtual Memory, Operating System]
pin: false
math: true
mermaid: true
---

<br/> 

## 가상 메모리의 필요성

---

초창기 컴퓨터는 메인 메모리의 크기가 실행하고자 하는 프로그램보다 커야했다. CPU가 오직 RAM(메인 메모리)과 소통하기 때문이다. 프로그램 전체를 RAM에 올리는 것은 쉽지않다. 컴퓨터의 사양이 각각 다르기 때문에 모든 컴퓨터에서 작동하는 프로그램을 만드는 것이 어렵고, <span style="color:#9fb584">**비용적인 측면**</span>에서도 부담이 크기 때문이다. 이를 해결하기 위해 오버레이 기법(애플리케이션의 일부만 RAM에 올리는 방법)을 개발하기도 했지만, 결국 시스템이 애플리케이션을 위한 충분한 공간을 가지고 있어야 했기 때문에 해결책이 되진 못했다. <span style="color:#9fb584">**용량 한계의 문제점**</span> 말고도 실제 메모리에서 작업을 하던 도중 발생하는 오류들을 해결하는 방식에도 위험이 있다. 메인 메모리에 직접 접근하여 작업 하던 중 오류가 발생하면 해당 부분을 한동안 사용할 수 없는 문제가 생기기 때문이다. 이에 대한 해결책으로 가상 메모리 기법이 개발되었고, 가상 메모리 기법의 필요성은 아래와 같다.<br/> 

### 1. 메인 메모리 효율적 사용

 가상 메모리는 각 프로그램이 사용하는 가상 주소 공간을 디스크에 저장하고, 자주 사용되는 부분만 메인 메모리로 가져와 사용한다. 즉, <span style="color:#9fb584">**메인 메모리를 디스크의 캐시로 사용하기 때문에, 하나의 메인 메모리에 여러 프로그램의 데이터와 코드를 적재하는 것이 가능**</span>해진다.

<br/> 

### 2. 메모리 관리 단순화

 가상 메모리는 각 프로세스마다 통일된 가상 주소 공간(상대 주소)를 배정한다. 실제 메모리 참조를 수행할 때 가상 주소를 물리 주소로 변환하기 때문이다. (MMU) 따라서 <span style="color:#9fb584">**각각의 프로세스에게 독립적인 공간을 가질 수 있게한다.**</span> 이는 링커 및 로더의 구현과 메모리 할당 방식 등을 단순화한다.

> CPU는 프로세스의 페이지 테이블을 참조하여 가상 주소를 기반으로 offset 값을 대입시켜 프로세스의 실제 주소인 물리 주소를 참조한다.<br/> A 프로세스의 가상 주소가 Ox1000 라고 한다면, CPU는 A 프로세스의 페이지 테이블을 사용해 실 주소인 Ox4000 이라는 물리 주소를 참조할 수 있게 된다.<br/> B 프로세스의 가상 주소도 Ox1000 라고 한다면, B 프로세스의 페이지 테이블을 사용해 실 주소 Ox6000을 참조할 수 있다.<br/> 두 프로세스는 동일한 가상 주소를 참조했지만, 실제로는 MMU가 페이지 테이블을 참조해서 실제 메모리 주소를 얻고 그 위치를 참조해 값을 가져오게 된다.<br/> 두 프로세스의 주소 공간이 겹치지 않으면서 같은 가상 주소를 사용하기 때문에, 프로그래머는 다른 프로세스를 관리해도 하나의 가상 주소(상대 주소)만 가지고 있으면 된다.

<br/> 

### 3. 메모리 보호 단순화

 가상 메모리는 <span style="color:#9fb584">**한 프로세스가 다른 프로세스의 주소 공간에 접근하는 것을 보호**</span>할 수 있다. 또한 가상 주소를 물리 주소로 변환할 때 참조하는 페이지 테이블의 각 엔트리에는 해당 가상 주소에 대한 <span style="color:#9fb584">**접근 권한**</span>이 명시된다. 따라서 허용되지 않은 주소 공간에 접근하는 것을 쉽게 막을 수 있다.

<br/> 
<br/> 

## 가상 메모리란

---

<span style="color:#9fb584">**CPU는 프로그램을 실행하기 위해 RAM을 사용**</span>하는데, 이 <span style="color:#9fb584">**RAM의 한정된 공간을 극복하기 위해 하드디스크의 일부 영역을 주 기억장치(메인 메모리)로 사용(Swapping)**</span>하며 (= 스왑 공간 Swap Space), 주 기억장치와 보조 기억장치 사이에서 <span style="color:#9fb584">**페이지**</span>라고 불리는 데이터 블록을 옮기는 작업을 반복함으로써 <span style="color:#9fb584">**실제보다 큰 주기억장치가 있는 것처럼 기능**</span>하게 만든다. 이로 인해 <span style="color:#9fb584">**물리적 메모리의 한계에도 불구하고 더 많은 양을 가진 프로그램들을 실행**</span>시킬 수 있다.

> Swapping : 주기억장치와 가상메모리 장치 사이의 데이터를 교환하는 기법이다.<br/> 물리 메모리가 꽉 찬 상태에서 페이지 부재가 발생했을 때 발생하며, 물리 메모리 상에서 가장 필요없는 페이지를 하드디스크로 내리고(swap-out) 그 공간에 요청한(부재) 페이지를 하드디스크에서 올려준다.(swap-in)

<br/> 

가상 메모리는 <span style="color:#9fb584">**시스템이 프로그램을 실행하기 위한 최소한 얼마만큼의 메모리가 필요한가에 대한 접근 방식**</span>으로, 실행에 필요한 일부분만 메모리에 로드하고 나머지는 디스크에 둔 후 필요할 때 교체하며 쓰는 방식으로 구현된다.


CPU는 프로그램을 실행하며 명령을 수행할 때 가상 메모리에 접근하기 위하여 MMU를 사용한다. <span style="color:#9fb584">**CPU는 가상 주소, 메모리는 물리 주소를 사용하기 때문에 MMU가 주소를 매핑하는 역할을 수행**</span>한다. 모든 메모리를 매핑하는 것은 비효율적이기 때문에 MMU는 메인 메모리를 페이지 단위로 나눠 각 페이지를 독립적으로 처리한다. 또한 <span style="color:#9fb584">**메인 메모리에는 필요한 페이지만 올려두는**</span>데 이 방식을 <span style="color:#9fb584">**요구 페이징 Demand Paging**</span> 이라 한다. 모든 데이터는 보조 기억장치에 존재하고, 필요할 때만 메인 메모리에 페이지를 올린다. 단순히 메인 메모리의 공간이 부족하다고 보조 기억장치까지 확장하여 사용하는 것이 아니다.

<br/> 
<br/> 


## 가상 메모리의 장점

---

- 메인 메모리를 하드 디스크의 캐시로 처리하여 <span style="color:#9fb584">**더 넓은 메모리 공간을 제공**</span>한다.
- 프로그램 실행에 필요한 최소 크기의 메모리만 올라가져 있기 때문에 <span style="color:#9fb584">**더 많은 프로그램을 동시 수행**</span> 할 수 있다.
- 프로그램이 이미 적재된 페이지를 접근할 경우 <span style="color:#9fb584">**메모리를 효율적으로 사용**</span>할 수 있다. 
- 프로그램이 다른 프로그램의 <span style="color:#9fb584">**영역을 접근하는 것을 보호**</span>할 수 있다.
- 메모리 <span style="color:#9fb584">**관리가 용이**</span>하다.
  - OS는 메모리 페이지 사용여부를 지속적으로 추적하여, 사용할 수 있는 공간이 남아있어도 일정 시간 쓰이지 않은 메모리 페이지를 스왑 공간으로 복사한다.
  - 어떤 프로그램이 스왑 아웃된 메모리 페이지에 접근하려할 경우, OS는 다른 메모리 페이지를 스왑 아웃하여 공간을 확보한 뒤, 요청받은 페이지를 스왑 공간으로부터 물리적 메모리로 스왑 인 한다.


<br/> 
<br/> 


## MMU (Memory Management Unit) 

---

<span style="color:#9fb584">**CPU가 메모리에 접근하는 것을 관리하는 컴퓨터 하드웨어 부품으로 가상 메모리 주소를 실 메모리 주소로 변환하는 장치**</span>이다. 하드웨어 장치인 MMU를 사용하는 이유는 소프트웨어 방식보다 하드웨어 장치가 주소 변환이 더 빠르기 때문이다.

- 가상 주소 : 프로세스가 참조하는 주소
- 물리 주소 : 실제 메모리 RAM 주소


![mmu](/assets/img/mmu.png)


<br/> 

### TBL

실제 물리 주소를 접근할 때 활용하는 MMU은, 추가적으로 하드웨어 보조장치인 <span style="color:#9fb584">**TLB(Translation Lookaside Buffer)**</span>을 활용해서 접근한다. 페이지 테이블이 주기억장치 상에 존재하기 때문에, 메모리를 액세스 할 때마다 주기억장치의 페이지 테이블, 기억장치에 필요한 데이터 총 2번 액세스 해야하기 때문에 시간이 오래걸리는 단점이 있다. 이 문제를 해결하기 위해 데이터에 접근할 때마다 메인 메모리에 접근하는 것이 아닌, <span style="color:#9fb584">**과거에 사용한 적이 있다면 이를 따로 레지스터에 캐싱 Caching하여 접근 속도를 높이는 보조장치**</span>인 TLB를 활용한다. 메인 메모리 접근 시간보다 레지스터 접근 시간이 현저하게 빠르기 때문에, 페이지 정보 캐시 장치로 접근 속도를 향상시키기 위하여 따로 보조장치를 두는 것이다. TLB가 hit일 경우 가상 주소를 물리 주소로 변환하기 위한 페이지 테이블에 접근할 필요가 없으며, TLB 프레임 주소를 토대로 데이터를 불러오기 위한 1번의 메모리 접근만 있으면 된다.


#### [ 페이징 메커니즘 with TLB ]

![tlb](/assets/img/tlb.png)


1. MMU에 가상 주소를 요청한다.
2. MMU는 TLB에서 최근에 가상 주소에서 물리 주소로 변환한 정보가 있는지 확인하고, 있다면 해당 정보를 활용한다.
3. TLB에 없다면 CR3에 등록된 base 주소로 접근해 메인 메모리에서 데이터를 찾는다.
4. 찾았다면 메인 메모리는 MMU에 물리 주소를 반환시킨다.
5. MMU는 해당 정보를 TLB에 캐싱하고 이 물리 주소를 기반으로 메인 메모리에 접근한다.
6. 메인 메모리는 해당 데이터를 CPU에 적재시켜서 프로세스를 수행한다.

<br/> 
<br/> 

## 페이징 Paging

---

- 디스크 공간을 쪼개 여러개의 Page라는 일정한 크기로 RAM이 사용할 수 있는 공간으로 분할하는 것이다. 
- RAM은 분할된 공간의 주소가 저장된 Page Table을 보고 분할된 디스크 공간에 접근한다.

<br/> 

### 페이지 Page

- 가상 메모리를 일정한 크기로 나눈 블록이다.
> 프레임 : 물리 메모리를 일정한 크기로 나눈 블록이다.<br/>페이지가 하나의 프레임을 할당 받아 물리 메모리에 위치함으로 페이지는 알맹이, 프레임은 알맹이가 들어갈 틀이라고 할 수 있다.<br/> 프레임을 할당 받지 못한 페이지는 외부 저장장치(하드디스크)에 저장된다.<br/> 프레임과 페이지는 같은 크기로 관리되며, 하드디스크와 메모리간 데이터 교환은 프레임 단위로 전송된다.
- 메모리 페이지는 시스템에 의해 할당되며 Heap에 있는 여러 객체를 포함시킬 수 있다.
- 일부 객체는 실제 여러 페이지에 걸쳐 있을 수 있다.
- 일반적으로 페이지의 크기는 16KB이며 깨끗한 페이지 clean Page와 더러운 페이지 dirty Page로 나뉜다.
  - 할당될 때는 깨끗한 페이지이지만, write를 시작하면 페이지는 더러워진다.
- <span style="color:#9fb584">**앱의 메모리 사용량은 페이지 수 * 페이지 크기**</span> 이다.




![memoryInUse](/assets/img/memoryInUse.webp){: width="300" height="300"}

> memory footprint : 프로그램이 동작 중에 사용하는 메인 메모리의 양<br/>
> <br/>
> 메모리(memory footprint)를 줄여야 하는 이유 : <br/>
> - 사용자에게 더 나은 경험을 제공할 수 있다.<br/>
> - 앱이 빠르게 실행된다.(launch faster)<br/> 
> - 시스템 성능이 증가한다.<br/> 
> - 자기 자신의 앱은 물론이고, 다른 앱들까지 메모리에 더 오래 유지되게 한다.<br/> 
> - 앱을 백그라운드에 놓을경우 메모리를 많이 사용하면 자동으로 앱이 종료되는데, A앱의 메모리 사용량이 높으면 A앱 뿐만 아닌 다른 앱도 메모리에서 내릴 수 있다.
> 

<br/> 


#### Clean & Dirty Page

20,000개의 정수로 이루어진 배열을 할당할때, 시스템은 6개의 페이지를 할당할 수 있다. 할당될 때의 페이지들은 clean하다.

![cleanDirtyPage1](/assets/img/cleanDirtyPage1.webp)

배열의 첫 번째 위치에 write를 시작하면 해당 페이지는 dirty 페이지가 된다. 아직 write를 하지 않은 페이지는 clean 페이지이다.

![cleanDirtyPage2](/assets/img/cleanDirtyPage2.webp)

> 프로퍼티 사용시 setter로 선언하지 않고 getter로만 선언하면 page가 항상 clean 상태로 유지된다.

<br/> 

#### Memory mapped files

디스크에 있지만 메모리에 로드된 파일이다. read-only 파일을 사용하는 경우 항상 깨끗한 파일이다. 커널은 디스크에서 RAM으로 오고 나갈때 이 파일을 관리한다.

Memory mapped file인 50KB 크기의 JPEG 파일이 있을 경우, 실제 메모리에 매핑될 때 대략 4개의 페이지에 매핑된다. 4번째 페이지는 공간이 남아있기 때문에 다른 데이터 저장이 가능하다. 단, 해당 페이지가 clean 상태여야 사용할 수 있다. 이전의 3페이지는 항상 시스템에 의해 제거될 수 있는 상태여야 한다.


![cleanDirtyPage3](/assets/img/cleanDirtyPage3.webp)

<br/> 

#### Clean Memory & Dirty Memory

-  <span style="color:#9fb584">**가상 메모리 = clean memory + dirty memory**</span>
- clean memory는 새로운 작업을 위해 재사용되거나 더 이상 필요하지 않을 경우 해제될 수 있다.
- dirty memory는 변경이 일어났으니, 디스크에 쓰여지거나 새로운 데이터로 업데이트 될 수 있다.

<br/> 

#### Clean Memory 
 : 값이 변경되지 않은 깨끗한 메모리이다.

- 새로운 데이터를 쓰기 위해 사용한다.
- 디스크에서 로드될 수 있으며 실행 코드, 읽기 전용 파일들을 의미한다.
- 페이지 해제(page out)가 될 수 있는 데이터로 memory-mapped file이다.
  > page out : 가상 메모리에서 프로세스가 필요로 하는 데이터를 물리적인 메모리에 올리고, 필요 없는 데이터는 디스크에 내보냄(page out)으로써 메모리를 효율적으로 사용하는데 여기서의 page out을 의미한다.
- 이미지, data Blob, training model, framework가 될 수 있다.
  - 모든 프레임워크는 DATA CONST 섹션을 가지고 있다.
  - 일반적으로 clean하지만, 런타임에 메서드 뒤섞기 등을 할 경우 dirty해질 수 있다.

<br/> 

#### Dirty Memory 
 : 값이 변경된 더러운 메모리로, 앱에 의해 쓰여진 모든 메모리이다.

- 쓰기 작업이 발생했기 때문에 다시 읽을 필요가 있거나, 변경된 내용을 디스크에 반영해야 할 때 사용한다.
- 페이지 해제가 될 수 없는 이미 수정된 데이터 영역이다.
- 힙, 싱글 톤 등 인스턴스들이 스택으로 채워진 메모리이다.
- 할당된 어떤 것이든 dirty memory가 될 수 있다.
  - 객체, 문자열, 배열, 디코딩된 이미지 버퍼, 프레임워크 등
  - 프레임워크는 DATA, DATA DIRTY 섹션을 가지고 있다.

<br/> 

#### Compressed Memory

- iOS 7부터 나온 개념으로, 메모리 효율성을 높이기 위해 나왔다.
- Compressed Memory는 사용되지 않는 메모리 영역이나 중복 데이터를 찾아내 압축하여 메모리 사용 공간을 축소한다.
- 가상 메모리 사용 시 디스크에서 swap하는 비용을 최소화한다.
- 메모리 압축은 물리적 메모리 사용을 최적화하면서 전력 소모를 최소화한다.
  - 효율적인 메모리 사용은 전력에도 영향을 미친다.

##### [ 동작 원리 ]

- 시스템의 메모리가 채워지기 시작하면 Compressed Memory는 메모리에서 가장 최근에 사용된 항목을 자동으로 압축하여 원래 크기의 반으로 압축한다.
- 만약 압축된 데이터가 필요한 경우 Compressed Memory가 즉시 압축 해제를 시도한다.

<br/> 


### 페이지 테이블 


- 가상 주소와 물리 주소를 엮어주는 매핑 테이블으로, <span style="color:#9fb584">**프로세스마다 하나씩 존재**</span>한다.
- 물리 주소에 있는 페이지 번호와 해당 페이지의 첫 물리 주소 정보를 매핑한 표이다.
  - 페이지는 일정한 크기를 가지기 때문에 메모리의 시작 주소만 가지고 있어도 된다.
- 반드시 <span style="color:#9fb584">**물리 메모리에 상주**</span>한다.
- 실행에 필요한 일부분만 메모리에 로드하고 필요할 때 교체하며 쓰는 방식으로 구현되기 때문에 프로세스의 페이지는 항상 물리 메모리에 적재될 필요가 없다.
  - 해당 페이지가 메모리에 있는지 나타내는 유/무효 비트(valid/invalid bit)로 페이지 테이블에 적재 여부 정보를 담는다.
  - 비트가 0이면 메모리, 1이면 하드디스크에 물리 데이터가 존재한다는 뜻이다.
  - 비트가 0일 때는 프레임 번호가 저장되고, 1일 때는 데이터가 스왑 영역에 있는 것이므로 스왑 영역의 페이지 주소가 저장된다.
- 프로세스가 많아질수록 테이블로 인한 메모리 사용이 많아진다.


<br/> 


### 가상 주소 접근 방법

1. 해당 프로세스의 페이지 테이블에 해당 가상 주소가 포함된 페이지 번호가 있는지 확인한다.
2. 페이지 번호가 있을 경우 페이지가 매핑된 첫 물리 주소를 알 수 있다. -> p`
3. p` + 변위 d가 실제 물리 주소가 된다.

<br/>
<br/> 


## 가상 메모리 메커니즘 - 페이징 시스템

---

크기가 동일한 페이지로 가상 주소 공간과 매칭하는 물리 주소 공간을 관리한다. Demand Paging 방식을 사용하기 때문에 프로세스가 실행될 때 `필요한 공간`만 적재시켜 실행시키고, 적재가 안된 부분을 실행해야할 경우 그때 메모리에 적재시켜 실행한다. `공간`을 페이지 단위로 나눠 메모리에 적재시키고 프로세스를 실행시켜 물리 메모리를 효율적으로 사용한다. 이 페이지를 관리하는 시스템을 페이징 시스템이라 한다.

- 프로세스는 동일한 물리 주소를 가리킬 수 있다. 
  - 실행 중인 프로세스들이 동일한 로직을 수행할 경우 따로 메모리에 적재되어 실행되는 것이 아닌 동일한 공간에서 프로세스를 수행하는 것이다. 
  - 동일한 로직의 프로세스가 read만 수행한다면 따로 메모리 공간을 할당 시킬 필요가 없어 공간, 메모리 할당 시간을 절약할 수 있다.
  - 특정 프로세스에서 write를 수행하여 물리 주소에서 데이터가 변경되면 두 프로세스는 서로 다른 로직을 수행한다.
  - 이때 물리 주소 복사를 수행하여 필요할 때만 공간 할당을 수행하여 효율성을 높인다. (copy-on-write)


<br/> 
<br/> 

## 가상 메모리의 동작 과정

---

1. 프로그램의 실행
    - CPU는 해당 프로그램의 명령어를 순차적으로 가져와 명령을 실행한다. 이 때 프로그램은 메모리의 실 주소를 사용하는 것이 아니라 가상 주소 logical address를 사용한다.
2. 주소 번역
    - 프로그램이 가상 주소를 사용하여 메모리에 접근하면, CPU는 MMU에게 가상 주소를 전달한다. MMU는 가상 주소를 페이지 테이블을 통해 실제 주소(물리 주소)로 변환한다.
3. 실 주소에 접근
    - 변환된 실 주소를 기반으로 CPU는 메인 메모리에 접근한다. 이 때 필요한 페이지가 메인 메모리에 있는 경우와 없는 경우로 나뉜다. 필요한 페이지만 메인 메모리에 올려두는 Demand paging 방식을 사용하기 때문이다. Demand paging은 페이지 테이블에서 해당 페이지가 메모리에 있는지 나타내는 유/무효 비트(valid/invalid bit)를 사용한다. 비트가 유효인 경우(필요한 페이지가 메인 메모리에 존재하는 경우) 그대로 사용한다.
4. 비트가 무효인 경우 (페이지가 메인 메모리에 없는 경우)
    - 필요한 페이지가 메인 메모리에 없다면 페이지 부재 Page Fault가 발생한다. 이 상황이 발생하면 MMU가 인터럽트 (페이지 부재 트랩)를 발생시킨다. 이후 OS가 해당 프로세스를 잠시 대기 상태로 만들고 보조 기억장치에서 페이지를 메인 메모리의 빈 공간에 올리고, 페이지 테이블을 갱신한다. 갱신 완료 시 해당 프로세스의 대기 상태를 해제하고, 명령을 다시 실행한다. 메모리에 공간이 부족한 경우 페이지 교체 기법을 사용하여 메모리 공간을 확보한다.

<br/> 

## 가상 메모리와 물리 메모리의 차이

---

| |가상 메모리|물리 메모리|
|:------:|:------:|:------:|
|최대 메모리 크기|CPU의 비트 값에 의존|CPU의 비트 값에 의존|
|메모리 분할 방식|세그먼테이션, 페이징, 페이징/세그먼테이션 혼용|가변분할, 고정분할|
|주소 지정 방식|가상주소|절대주소, 상대 주소|

<br/>


<br/> 

[^footnote]: The footnote source
[^fn-nth-2]: The 2nd footnote source
